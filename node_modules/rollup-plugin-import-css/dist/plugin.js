import { createFilter } from '@rollup/pluginutils';
import path from 'path';

var index = (options = {}) => {
  if (!options.transform) options.transform = (code) => code;
  const styles = {};
  const imports = {};
  const alwaysOutput = options.alwaysOutput ?? false;
  const preserveImports = options.preserveImports ?? true;
  const filter = createFilter(options.include ?? ["**/*.css"], options.exclude ?? []);
  const getRecursiveImportOrder = (id, getModuleInfo, seen = /* @__PURE__ */ new Set()) => {
    if (seen.has(id)) return [];
    seen.add(id);
    const result = [id];
    const moduleInfo = getModuleInfo(id);
    if (moduleInfo) {
      getModuleInfo(id).importedIds.forEach((importFile) => {
        result.push(...getRecursiveImportOrder(importFile, getModuleInfo, seen));
      });
    }
    return result;
  };
  const minifyCSS = (css) => {
    return css.replace(/("([^"\\]|\\.)*"|'([^'\\]|\\.)*')|\/\*[^]*?\*\//g, (_, quoted) => quoted || "").replace(/\s*;\s*(})/g, ";$1").replace(/\s*([*$~^|]?=|[{};,>~]|!important)\s*/g, "$1").replace(/\s*([+-])\s*(?=[^}]*\{)/g, "$1").replace(/([[(])\s+/g, "$1").replace(/\s+([\])])/g, "$1").replace(/({[^}]*?)\s*:\s*/g, "$1:").replace(/^\s+|\s+$/g, "").replace(/(\s)\s+/g, "$1").replace(/\n+/g, " ");
  };
  return {
    name: "import-css",
    resolveId(source, importer) {
      if (source.endsWith(".css") && (source.startsWith(".") || source.startsWith("/"))) {
        (imports[importer] = imports[importer] ?? []).push(source);
        return { id: path.resolve(path.dirname(importer), source) };
      }
      return null;
    },
    /* convert the css file to a module and save the code for a file output */
    async transform(code, id) {
      if (!filter(id)) return;
      const transformedCode = options.minify ? minifyCSS(await options.transform(code)) : await options.transform(code);
      if (!styles[id] || styles[id] != transformedCode) {
        styles[id] = transformedCode;
      }
      const moduleInfo = this.getModuleInfo(id);
      const attributes = moduleInfo.assertions != void 0 ? moduleInfo.assertions : moduleInfo.attributes;
      if (options.modules || (attributes == null ? void 0 : attributes.type) == "css") {
        return {
          code: `const sheet = new CSSStyleSheet();sheet.replaceSync(${JSON.stringify(transformedCode)});export default sheet;`,
          map: null
        };
      }
      if (options.inject) {
        return {
          code: `if(typeof document!=="undefined")document.head.appendChild(document.createElement("style")).textContent=${JSON.stringify(transformedCode)};`,
          map: null
        };
      }
      return {
        code: `export default ${JSON.stringify(transformedCode)};`,
        map: null
      };
    },
    /* output a css file with all css that was imported without being assigned a variable */
    generateBundle(opts, bundle) {
      const modules = Object.keys(bundle).reduce((modules2, file) => Object.assign(modules2, bundle[file].modules), {});
      const entryChunk = Object.values(bundle).find((chunk) => chunk.facadeModuleId).facadeModuleId;
      const stylesheets = Object.keys(styles).filter((id) => !modules[id]);
      if (!stylesheets.length) return;
      const moduleIds = getRecursiveImportOrder(entryChunk, this.getModuleInfo);
      stylesheets.sort((a, b) => moduleIds.indexOf(a) - moduleIds.indexOf(b));
      if (opts.preserveModules && !options.output) {
        for (let id of stylesheets) {
          const relativeToEntry = path.dirname(path.relative(entryChunk, id));
          const outputPath = opts.dir ? opts.dir : path.dirname(opts.file);
          const relativePath = path.join(path.join(outputPath, relativeToEntry), path.basename(id));
          const fileName = relativePath.includes("node_modules") ? relativePath.split("/").at(-1) : relativePath;
          if (styles[id].trim().length <= 0 && !alwaysOutput) continue;
          this.emitFile({ type: "asset", fileName, source: styles[id] });
        }
        if (preserveImports) {
          for (let chunk of Object.values(bundle)) {
            if (chunk.type != "chunk" || !imports[chunk.facadeModuleId]) continue;
            for (let file of imports[chunk.facadeModuleId].reverse()) {
              const importPath = file.includes("node_modules") ? `./${file.split("/").at(-1)}` : file;
              if (chunk.code.includes(importPath)) continue;
              chunk.code = `import "${importPath}";
${chunk.code}`;
            }
          }
        }
        return;
      }
      const css = stylesheets.map((id) => styles[id]).join("\n");
      if (css.trim().length <= 0 && !alwaysOutput) return;
      const getAssetName = () => {
        const fileName = options.output ?? (opts.file ?? "bundle.js");
        return `${path.basename(fileName, path.extname(fileName))}.css`;
      };
      const getAssetFileName = () => {
        if (options.output) return options.output;
        if (opts.assetFileNames) return void 0;
        return getAssetName();
      };
      this.emitFile({
        type: "asset",
        name: getAssetName(),
        fileName: getAssetFileName(),
        source: css
      });
    }
  };
};

export { index as default };
