{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/utils/towersLayout.ts","vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/utils/towersLayout.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;AAKhG;;;GAGG;AACH,MAAM,UAAU,gCAAgC,CAAC,oBAAiC,EAAE,mBAA6B;IAChH,MAAM,eAAe,GAAG,oBAAoB,CAAC,KAAK,CAAC;IACnD,MAAM,gBAAgB,GAAG,oBAAoB,CAAC,YAAY,CAAC;IAE3D,IAAI,SAAS,GAAG,MAAM,CAAC,SAAS,CAAC;IAEjC,yFAAyF;IACzF,IAAI,iBAAiB,GAAG,CAAC,CAAC;IAC1B,KAAK,MAAM,aAAa,IAAI,mBAAmB,EAAE,CAAC;QACjD,MAAM,kBAAkB,GAAG,iBAAiB,GAAG,aAAa,CAAC,KAAK,CAAC;QAEnE,iEAAiE;QACjE,MAAM,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,eAAe,EAAE,iBAAiB,CAAC,CAAC;QACjE,MAAM,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,gBAAgB,EAAE,kBAAkB,CAAC,CAAC;QAEpE,IAAI,WAAW,GAAG,YAAY,EAAE,CAAC;YAChC,iDAAiD;YACjD,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,aAAa,CAAC,MAAM,CAAC,CAAC;QACvD,CAAC;QAED,iBAAiB,GAAG,kBAAkB,CAAC;IACxC,CAAC;IAED,IAAI,gBAAgB,GAAG,iBAAiB,EAAE,CAAC;QAC1C,OAAO,CAAC,CAAC;IACV,CAAC;IAED,oCAAoC;IACpC,OAAO,SAAS,KAAK,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;AACvD,CAAC","file":"towersLayout.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Size2D } from '../../../../../../common/core/2d/size.js';\nimport { OffsetRange } from '../../../../../../common/core/ranges/offsetRange.js';\n\n/**\n * The tower areas are arranged from left to right, touch and are aligned at the bottom.\n * How high can a tower be placed at the requested horizontal range, so that its size fits into the union of the stacked availableTowerAreas?\n */\nexport function getMaxTowerHeightInAvailableArea(towerHorizontalRange: OffsetRange, availableTowerAreas: Size2D[]): number {\n\tconst towerLeftOffset = towerHorizontalRange.start;\n\tconst towerRightOffset = towerHorizontalRange.endExclusive;\n\n\tlet minHeight = Number.MAX_VALUE;\n\n\t// Calculate the accumulated width to find which tower areas the requested tower overlaps\n\tlet currentLeftOffset = 0;\n\tfor (const availableArea of availableTowerAreas) {\n\t\tconst currentRightOffset = currentLeftOffset + availableArea.width;\n\n\t\t// Check if the requested tower overlaps with this available area\n\t\tconst overlapLeft = Math.max(towerLeftOffset, currentLeftOffset);\n\t\tconst overlapRight = Math.min(towerRightOffset, currentRightOffset);\n\n\t\tif (overlapLeft < overlapRight) {\n\t\t\t// There is an overlap - track the minimum height\n\t\t\tminHeight = Math.min(minHeight, availableArea.height);\n\t\t}\n\n\t\tcurrentLeftOffset = currentRightOffset;\n\t}\n\n\tif (towerRightOffset > currentLeftOffset) {\n\t\treturn 0;\n\t}\n\n\t// If no overlap was found, return 0\n\treturn minHeight === Number.MAX_VALUE ? 0 : minHeight;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Size2D } from '../../../../../../common/core/2d/size.js';\nimport { OffsetRange } from '../../../../../../common/core/ranges/offsetRange.js';\n\n/**\n * The tower areas are arranged from left to right, touch and are aligned at the bottom.\n * How high can a tower be placed at the requested horizontal range, so that its size fits into the union of the stacked availableTowerAreas?\n */\nexport function getMaxTowerHeightInAvailableArea(towerHorizontalRange: OffsetRange, availableTowerAreas: Size2D[]): number {\n\tconst towerLeftOffset = towerHorizontalRange.start;\n\tconst towerRightOffset = towerHorizontalRange.endExclusive;\n\n\tlet minHeight = Number.MAX_VALUE;\n\n\t// Calculate the accumulated width to find which tower areas the requested tower overlaps\n\tlet currentLeftOffset = 0;\n\tfor (const availableArea of availableTowerAreas) {\n\t\tconst currentRightOffset = currentLeftOffset + availableArea.width;\n\n\t\t// Check if the requested tower overlaps with this available area\n\t\tconst overlapLeft = Math.max(towerLeftOffset, currentLeftOffset);\n\t\tconst overlapRight = Math.min(towerRightOffset, currentRightOffset);\n\n\t\tif (overlapLeft < overlapRight) {\n\t\t\t// There is an overlap - track the minimum height\n\t\t\tminHeight = Math.min(minHeight, availableArea.height);\n\t\t}\n\n\t\tcurrentLeftOffset = currentRightOffset;\n\t}\n\n\tif (towerRightOffset > currentLeftOffset) {\n\t\treturn 0;\n\t}\n\n\t// If no overlap was found, return 0\n\treturn minHeight === Number.MAX_VALUE ? 0 : minHeight;\n}\n"]}