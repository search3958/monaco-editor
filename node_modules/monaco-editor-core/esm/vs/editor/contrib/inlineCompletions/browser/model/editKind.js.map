{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/contrib/inlineCompletions/browser/model/editKind.ts","vs/editor/contrib/inlineCompletions/browser/model/editKind.ts"],"names":[],"mappings":"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","file":"editKind.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../../../common/core/position.js';\nimport { StringEdit, StringReplacement } from '../../../../common/core/edits/stringEdit.js';\nimport { ITextModel } from '../../../../common/model.js';\n\nconst syntacticalChars = new Set([';', ',', '=', '+', '-', '*', '/', '{', '}', '(', ')', '[', ']', '<', '>', ':', '.', '!', '?', '&', '|', '^', '%', '@', '#', '~', '`', '\\\\', '\\'', '\"', '$']);\n\nfunction isSyntacticalChar(char: string): boolean {\n\treturn syntacticalChars.has(char);\n}\n\nfunction isIdentifierChar(char: string): boolean {\n\treturn /[a-zA-Z0-9_]/.test(char);\n}\n\nfunction isWhitespaceChar(char: string): boolean {\n\treturn char === ' ' || char === '\\t';\n}\n\ntype SingleCharacterKind = 'syntactical' | 'identifier' | 'whitespace';\n\ninterface SingleLineTextShape {\n\treadonly kind: 'singleLine';\n\treadonly isSingleCharacter: boolean;\n\treadonly singleCharacterKind: SingleCharacterKind | undefined;\n\treadonly isWord: boolean;\n\treadonly isMultipleWords: boolean;\n\treadonly isMultipleWhitespace: boolean;\n\treadonly hasDuplicatedWhitespace: boolean;\n}\n\ninterface MultiLineTextShape {\n\treadonly kind: 'multiLine';\n\treadonly lineCount: number;\n}\n\ntype TextShape = SingleLineTextShape | MultiLineTextShape;\n\nfunction analyzeTextShape(text: string): TextShape {\n\tconst lines = text.split(/\\r\\n|\\r|\\n/);\n\tif (lines.length > 1) {\n\t\treturn {\n\t\t\tkind: 'multiLine',\n\t\t\tlineCount: lines.length,\n\t\t};\n\t}\n\n\tconst isSingleChar = text.length === 1;\n\tlet singleCharKind: SingleCharacterKind | undefined;\n\tif (isSingleChar) {\n\t\tif (isSyntacticalChar(text)) {\n\t\t\tsingleCharKind = 'syntactical';\n\t\t} else if (isIdentifierChar(text)) {\n\t\t\tsingleCharKind = 'identifier';\n\t\t} else if (isWhitespaceChar(text)) {\n\t\t\tsingleCharKind = 'whitespace';\n\t\t}\n\t}\n\n\t// Analyze whitespace patterns\n\tconst whitespaceMatches = text.match(/[ \\t]+/g) || [];\n\tconst isMultipleWhitespace = whitespaceMatches.some(ws => ws.length > 1);\n\tconst hasDuplicatedWhitespace = whitespaceMatches.some(ws =>\n\t\t(ws.includes('  ') || ws.includes('\\t\\t'))\n\t);\n\n\t// Analyze word patterns\n\tconst words = text.split(/\\s+/).filter(w => w.length > 0);\n\tconst isWord = words.length === 1 && /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(words[0]);\n\tconst isMultipleWords = words.length > 1;\n\n\treturn {\n\t\tkind: 'singleLine',\n\t\tisSingleCharacter: isSingleChar,\n\t\tsingleCharacterKind: singleCharKind,\n\t\tisWord,\n\t\tisMultipleWords,\n\t\tisMultipleWhitespace,\n\t\thasDuplicatedWhitespace,\n\t};\n}\n\ntype InsertLocationShape = 'endOfLine' | 'emptyLine' | 'startOfLine' | 'middleOfLine';\n\ninterface InsertLocationRelativeToCursor {\n\treadonly atCursor: boolean;\n\treadonly beforeCursorOnSameLine: boolean;\n\treadonly afterCursorOnSameLine: boolean;\n\treadonly linesAbove: number | undefined;\n\treadonly linesBelow: number | undefined;\n}\n\nexport interface InsertProperties {\n\treadonly textShape: TextShape;\n\treadonly locationShape: InsertLocationShape;\n\treadonly relativeToCursor: InsertLocationRelativeToCursor | undefined;\n}\n\nexport interface DeleteProperties {\n\treadonly textShape: TextShape;\n\treadonly isAtEndOfLine: boolean;\n\treadonly deletesEntireLineContent: boolean;\n}\n\nexport interface ReplaceProperties {\n\treadonly isWordToWordReplacement: boolean;\n\treadonly isAdditive: boolean;\n\treadonly isSubtractive: boolean;\n\treadonly isSingleLineToSingleLine: boolean;\n\treadonly isSingleLineToMultiLine: boolean;\n\treadonly isMultiLineToSingleLine: boolean;\n}\n\ntype EditOperation = 'insert' | 'delete' | 'replace';\n\ninterface IInlineSuggestionEditKindEdit {\n\treadonly operation: EditOperation;\n\treadonly properties: InsertProperties | DeleteProperties | ReplaceProperties;\n\treadonly charactersInserted: number;\n\treadonly charactersDeleted: number;\n\treadonly linesInserted: number;\n\treadonly linesDeleted: number;\n}\nexport class InlineSuggestionEditKind {\n\tconstructor(readonly edits: IInlineSuggestionEditKindEdit[]) { }\n\ttoString(): string {\n\t\treturn JSON.stringify({ edits: this.edits });\n\t}\n}\n\nexport function computeEditKind(edit: StringEdit, textModel: ITextModel, cursorPosition?: Position): InlineSuggestionEditKind | undefined {\n\tif (edit.replacements.length === 0) {\n\t\t// Empty edit - return undefined as there's no edit to classify\n\t\treturn undefined;\n\t}\n\n\treturn new InlineSuggestionEditKind(edit.replacements.map(rep => computeSingleEditKind(rep, textModel, cursorPosition)));\n}\n\nfunction countLines(text: string): number {\n\tif (text.length === 0) {\n\t\treturn 0;\n\t}\n\treturn text.split(/\\r\\n|\\r|\\n/).length - 1;\n}\n\nfunction computeSingleEditKind(replacement: StringReplacement, textModel: ITextModel, cursorPosition?: Position): IInlineSuggestionEditKindEdit {\n\tconst replaceRange = replacement.replaceRange;\n\tconst newText = replacement.newText;\n\tconst deletedLength = replaceRange.length;\n\tconst insertedLength = newText.length;\n\tconst linesInserted = countLines(newText);\n\n\tconst kind = replaceRange.isEmpty ? 'insert' : (newText.length === 0 ? 'delete' : 'replace');\n\tswitch (kind) {\n\t\tcase 'insert':\n\t\t\treturn {\n\t\t\t\toperation: 'insert',\n\t\t\t\tproperties: computeInsertProperties(replaceRange.start, newText, textModel, cursorPosition),\n\t\t\t\tcharactersInserted: insertedLength,\n\t\t\t\tcharactersDeleted: 0,\n\t\t\t\tlinesInserted,\n\t\t\t\tlinesDeleted: 0,\n\t\t\t};\n\t\tcase 'delete': {\n\t\t\tconst deletedText = textModel.getValue().substring(replaceRange.start, replaceRange.endExclusive);\n\t\t\treturn {\n\t\t\t\toperation: 'delete',\n\t\t\t\tproperties: computeDeleteProperties(replaceRange.start, replaceRange.endExclusive, textModel),\n\t\t\t\tcharactersInserted: 0,\n\t\t\t\tcharactersDeleted: deletedLength,\n\t\t\t\tlinesInserted: 0,\n\t\t\t\tlinesDeleted: countLines(deletedText),\n\t\t\t};\n\t\t}\n\t\tcase 'replace': {\n\t\t\tconst oldText = textModel.getValue().substring(replaceRange.start, replaceRange.endExclusive);\n\t\t\treturn {\n\t\t\t\toperation: 'replace',\n\t\t\t\tproperties: computeReplaceProperties(oldText, newText),\n\t\t\t\tcharactersInserted: insertedLength,\n\t\t\t\tcharactersDeleted: deletedLength,\n\t\t\t\tlinesInserted,\n\t\t\t\tlinesDeleted: countLines(oldText),\n\t\t\t};\n\t\t}\n\t}\n}\n\nfunction computeInsertProperties(offset: number, newText: string, textModel: ITextModel, cursorPosition?: Position): InsertProperties {\n\tconst textShape = analyzeTextShape(newText);\n\tconst insertPosition = textModel.getPositionAt(offset);\n\tconst lineContent = textModel.getLineContent(insertPosition.lineNumber);\n\tconst lineLength = lineContent.length;\n\n\t// Determine location shape\n\tlet locationShape: InsertLocationShape;\n\tconst isLineEmpty = lineContent.trim().length === 0;\n\tconst isAtEndOfLine = insertPosition.column > lineLength;\n\tconst isAtStartOfLine = insertPosition.column === 1;\n\n\tif (isLineEmpty) {\n\t\tlocationShape = 'emptyLine';\n\t} else if (isAtEndOfLine) {\n\t\tlocationShape = 'endOfLine';\n\t} else if (isAtStartOfLine) {\n\t\tlocationShape = 'startOfLine';\n\t} else {\n\t\tlocationShape = 'middleOfLine';\n\t}\n\n\t// Compute relative to cursor if cursor position is provided\n\tlet relativeToCursor: InsertLocationRelativeToCursor | undefined;\n\tif (cursorPosition) {\n\t\tconst cursorLine = cursorPosition.lineNumber;\n\t\tconst insertLine = insertPosition.lineNumber;\n\t\tconst cursorColumn = cursorPosition.column;\n\t\tconst insertColumn = insertPosition.column;\n\n\t\tconst atCursor = cursorLine === insertLine && cursorColumn === insertColumn;\n\t\tconst beforeCursorOnSameLine = cursorLine === insertLine && insertColumn < cursorColumn;\n\t\tconst afterCursorOnSameLine = cursorLine === insertLine && insertColumn > cursorColumn;\n\t\tconst linesAbove = insertLine < cursorLine ? cursorLine - insertLine : undefined;\n\t\tconst linesBelow = insertLine > cursorLine ? insertLine - cursorLine : undefined;\n\n\t\trelativeToCursor = {\n\t\t\tatCursor,\n\t\t\tbeforeCursorOnSameLine,\n\t\t\tafterCursorOnSameLine,\n\t\t\tlinesAbove,\n\t\t\tlinesBelow,\n\t\t};\n\t}\n\n\treturn {\n\t\ttextShape,\n\t\tlocationShape,\n\t\trelativeToCursor,\n\t};\n}\n\nfunction computeDeleteProperties(startOffset: number, endOffset: number, textModel: ITextModel): DeleteProperties {\n\tconst deletedText = textModel.getValue().substring(startOffset, endOffset);\n\tconst textShape = analyzeTextShape(deletedText);\n\n\tconst startPosition = textModel.getPositionAt(startOffset);\n\tconst endPosition = textModel.getPositionAt(endOffset);\n\n\t// Check if delete is at end of line\n\tconst lineContent = textModel.getLineContent(endPosition.lineNumber);\n\tconst isAtEndOfLine = endPosition.column > lineContent.length;\n\n\t// Check if entire line content is deleted\n\tconst deletesEntireLineContent =\n\t\tstartPosition.lineNumber === endPosition.lineNumber &&\n\t\tstartPosition.column === 1 &&\n\t\tendPosition.column > lineContent.length;\n\n\treturn {\n\t\ttextShape,\n\t\tisAtEndOfLine,\n\t\tdeletesEntireLineContent,\n\t};\n}\n\nfunction computeReplaceProperties(oldText: string, newText: string): ReplaceProperties {\n\tconst oldShape = analyzeTextShape(oldText);\n\tconst newShape = analyzeTextShape(newText);\n\n\tconst oldIsWord = oldShape.kind === 'singleLine' && oldShape.isWord;\n\tconst newIsWord = newShape.kind === 'singleLine' && newShape.isWord;\n\tconst isWordToWordReplacement = oldIsWord && newIsWord;\n\n\tconst isAdditive = newText.length > oldText.length;\n\tconst isSubtractive = newText.length < oldText.length;\n\n\tconst isSingleLineToSingleLine = oldShape.kind === 'singleLine' && newShape.kind === 'singleLine';\n\tconst isSingleLineToMultiLine = oldShape.kind === 'singleLine' && newShape.kind === 'multiLine';\n\tconst isMultiLineToSingleLine = oldShape.kind === 'multiLine' && newShape.kind === 'singleLine';\n\n\treturn {\n\t\tisWordToWordReplacement,\n\t\tisAdditive,\n\t\tisSubtractive,\n\t\tisSingleLineToSingleLine,\n\t\tisSingleLineToMultiLine,\n\t\tisMultiLineToSingleLine,\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../../../common/core/position.js';\nimport { StringEdit, StringReplacement } from '../../../../common/core/edits/stringEdit.js';\nimport { ITextModel } from '../../../../common/model.js';\n\nconst syntacticalChars = new Set([';', ',', '=', '+', '-', '*', '/', '{', '}', '(', ')', '[', ']', '<', '>', ':', '.', '!', '?', '&', '|', '^', '%', '@', '#', '~', '`', '\\\\', '\\'', '\"', '$']);\n\nfunction isSyntacticalChar(char: string): boolean {\n\treturn syntacticalChars.has(char);\n}\n\nfunction isIdentifierChar(char: string): boolean {\n\treturn /[a-zA-Z0-9_]/.test(char);\n}\n\nfunction isWhitespaceChar(char: string): boolean {\n\treturn char === ' ' || char === '\\t';\n}\n\ntype SingleCharacterKind = 'syntactical' | 'identifier' | 'whitespace';\n\ninterface SingleLineTextShape {\n\treadonly kind: 'singleLine';\n\treadonly isSingleCharacter: boolean;\n\treadonly singleCharacterKind: SingleCharacterKind | undefined;\n\treadonly isWord: boolean;\n\treadonly isMultipleWords: boolean;\n\treadonly isMultipleWhitespace: boolean;\n\treadonly hasDuplicatedWhitespace: boolean;\n}\n\ninterface MultiLineTextShape {\n\treadonly kind: 'multiLine';\n\treadonly lineCount: number;\n}\n\ntype TextShape = SingleLineTextShape | MultiLineTextShape;\n\nfunction analyzeTextShape(text: string): TextShape {\n\tconst lines = text.split(/\\r\\n|\\r|\\n/);\n\tif (lines.length > 1) {\n\t\treturn {\n\t\t\tkind: 'multiLine',\n\t\t\tlineCount: lines.length,\n\t\t};\n\t}\n\n\tconst isSingleChar = text.length === 1;\n\tlet singleCharKind: SingleCharacterKind | undefined;\n\tif (isSingleChar) {\n\t\tif (isSyntacticalChar(text)) {\n\t\t\tsingleCharKind = 'syntactical';\n\t\t} else if (isIdentifierChar(text)) {\n\t\t\tsingleCharKind = 'identifier';\n\t\t} else if (isWhitespaceChar(text)) {\n\t\t\tsingleCharKind = 'whitespace';\n\t\t}\n\t}\n\n\t// Analyze whitespace patterns\n\tconst whitespaceMatches = text.match(/[ \\t]+/g) || [];\n\tconst isMultipleWhitespace = whitespaceMatches.some(ws => ws.length > 1);\n\tconst hasDuplicatedWhitespace = whitespaceMatches.some(ws =>\n\t\t(ws.includes('  ') || ws.includes('\\t\\t'))\n\t);\n\n\t// Analyze word patterns\n\tconst words = text.split(/\\s+/).filter(w => w.length > 0);\n\tconst isWord = words.length === 1 && /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(words[0]);\n\tconst isMultipleWords = words.length > 1;\n\n\treturn {\n\t\tkind: 'singleLine',\n\t\tisSingleCharacter: isSingleChar,\n\t\tsingleCharacterKind: singleCharKind,\n\t\tisWord,\n\t\tisMultipleWords,\n\t\tisMultipleWhitespace,\n\t\thasDuplicatedWhitespace,\n\t};\n}\n\ntype InsertLocationShape = 'endOfLine' | 'emptyLine' | 'startOfLine' | 'middleOfLine';\n\ninterface InsertLocationRelativeToCursor {\n\treadonly atCursor: boolean;\n\treadonly beforeCursorOnSameLine: boolean;\n\treadonly afterCursorOnSameLine: boolean;\n\treadonly linesAbove: number | undefined;\n\treadonly linesBelow: number | undefined;\n}\n\nexport interface InsertProperties {\n\treadonly textShape: TextShape;\n\treadonly locationShape: InsertLocationShape;\n\treadonly relativeToCursor: InsertLocationRelativeToCursor | undefined;\n}\n\nexport interface DeleteProperties {\n\treadonly textShape: TextShape;\n\treadonly isAtEndOfLine: boolean;\n\treadonly deletesEntireLineContent: boolean;\n}\n\nexport interface ReplaceProperties {\n\treadonly isWordToWordReplacement: boolean;\n\treadonly isAdditive: boolean;\n\treadonly isSubtractive: boolean;\n\treadonly isSingleLineToSingleLine: boolean;\n\treadonly isSingleLineToMultiLine: boolean;\n\treadonly isMultiLineToSingleLine: boolean;\n}\n\ntype EditOperation = 'insert' | 'delete' | 'replace';\n\ninterface IInlineSuggestionEditKindEdit {\n\treadonly operation: EditOperation;\n\treadonly properties: InsertProperties | DeleteProperties | ReplaceProperties;\n\treadonly charactersInserted: number;\n\treadonly charactersDeleted: number;\n\treadonly linesInserted: number;\n\treadonly linesDeleted: number;\n}\nexport class InlineSuggestionEditKind {\n\tconstructor(readonly edits: IInlineSuggestionEditKindEdit[]) { }\n\ttoString(): string {\n\t\treturn JSON.stringify({ edits: this.edits });\n\t}\n}\n\nexport function computeEditKind(edit: StringEdit, textModel: ITextModel, cursorPosition?: Position): InlineSuggestionEditKind | undefined {\n\tif (edit.replacements.length === 0) {\n\t\t// Empty edit - return undefined as there's no edit to classify\n\t\treturn undefined;\n\t}\n\n\treturn new InlineSuggestionEditKind(edit.replacements.map(rep => computeSingleEditKind(rep, textModel, cursorPosition)));\n}\n\nfunction countLines(text: string): number {\n\tif (text.length === 0) {\n\t\treturn 0;\n\t}\n\treturn text.split(/\\r\\n|\\r|\\n/).length - 1;\n}\n\nfunction computeSingleEditKind(replacement: StringReplacement, textModel: ITextModel, cursorPosition?: Position): IInlineSuggestionEditKindEdit {\n\tconst replaceRange = replacement.replaceRange;\n\tconst newText = replacement.newText;\n\tconst deletedLength = replaceRange.length;\n\tconst insertedLength = newText.length;\n\tconst linesInserted = countLines(newText);\n\n\tconst kind = replaceRange.isEmpty ? 'insert' : (newText.length === 0 ? 'delete' : 'replace');\n\tswitch (kind) {\n\t\tcase 'insert':\n\t\t\treturn {\n\t\t\t\toperation: 'insert',\n\t\t\t\tproperties: computeInsertProperties(replaceRange.start, newText, textModel, cursorPosition),\n\t\t\t\tcharactersInserted: insertedLength,\n\t\t\t\tcharactersDeleted: 0,\n\t\t\t\tlinesInserted,\n\t\t\t\tlinesDeleted: 0,\n\t\t\t};\n\t\tcase 'delete': {\n\t\t\tconst deletedText = textModel.getValue().substring(replaceRange.start, replaceRange.endExclusive);\n\t\t\treturn {\n\t\t\t\toperation: 'delete',\n\t\t\t\tproperties: computeDeleteProperties(replaceRange.start, replaceRange.endExclusive, textModel),\n\t\t\t\tcharactersInserted: 0,\n\t\t\t\tcharactersDeleted: deletedLength,\n\t\t\t\tlinesInserted: 0,\n\t\t\t\tlinesDeleted: countLines(deletedText),\n\t\t\t};\n\t\t}\n\t\tcase 'replace': {\n\t\t\tconst oldText = textModel.getValue().substring(replaceRange.start, replaceRange.endExclusive);\n\t\t\treturn {\n\t\t\t\toperation: 'replace',\n\t\t\t\tproperties: computeReplaceProperties(oldText, newText),\n\t\t\t\tcharactersInserted: insertedLength,\n\t\t\t\tcharactersDeleted: deletedLength,\n\t\t\t\tlinesInserted,\n\t\t\t\tlinesDeleted: countLines(oldText),\n\t\t\t};\n\t\t}\n\t}\n}\n\nfunction computeInsertProperties(offset: number, newText: string, textModel: ITextModel, cursorPosition?: Position): InsertProperties {\n\tconst textShape = analyzeTextShape(newText);\n\tconst insertPosition = textModel.getPositionAt(offset);\n\tconst lineContent = textModel.getLineContent(insertPosition.lineNumber);\n\tconst lineLength = lineContent.length;\n\n\t// Determine location shape\n\tlet locationShape: InsertLocationShape;\n\tconst isLineEmpty = lineContent.trim().length === 0;\n\tconst isAtEndOfLine = insertPosition.column > lineLength;\n\tconst isAtStartOfLine = insertPosition.column === 1;\n\n\tif (isLineEmpty) {\n\t\tlocationShape = 'emptyLine';\n\t} else if (isAtEndOfLine) {\n\t\tlocationShape = 'endOfLine';\n\t} else if (isAtStartOfLine) {\n\t\tlocationShape = 'startOfLine';\n\t} else {\n\t\tlocationShape = 'middleOfLine';\n\t}\n\n\t// Compute relative to cursor if cursor position is provided\n\tlet relativeToCursor: InsertLocationRelativeToCursor | undefined;\n\tif (cursorPosition) {\n\t\tconst cursorLine = cursorPosition.lineNumber;\n\t\tconst insertLine = insertPosition.lineNumber;\n\t\tconst cursorColumn = cursorPosition.column;\n\t\tconst insertColumn = insertPosition.column;\n\n\t\tconst atCursor = cursorLine === insertLine && cursorColumn === insertColumn;\n\t\tconst beforeCursorOnSameLine = cursorLine === insertLine && insertColumn < cursorColumn;\n\t\tconst afterCursorOnSameLine = cursorLine === insertLine && insertColumn > cursorColumn;\n\t\tconst linesAbove = insertLine < cursorLine ? cursorLine - insertLine : undefined;\n\t\tconst linesBelow = insertLine > cursorLine ? insertLine - cursorLine : undefined;\n\n\t\trelativeToCursor = {\n\t\t\tatCursor,\n\t\t\tbeforeCursorOnSameLine,\n\t\t\tafterCursorOnSameLine,\n\t\t\tlinesAbove,\n\t\t\tlinesBelow,\n\t\t};\n\t}\n\n\treturn {\n\t\ttextShape,\n\t\tlocationShape,\n\t\trelativeToCursor,\n\t};\n}\n\nfunction computeDeleteProperties(startOffset: number, endOffset: number, textModel: ITextModel): DeleteProperties {\n\tconst deletedText = textModel.getValue().substring(startOffset, endOffset);\n\tconst textShape = analyzeTextShape(deletedText);\n\n\tconst startPosition = textModel.getPositionAt(startOffset);\n\tconst endPosition = textModel.getPositionAt(endOffset);\n\n\t// Check if delete is at end of line\n\tconst lineContent = textModel.getLineContent(endPosition.lineNumber);\n\tconst isAtEndOfLine = endPosition.column > lineContent.length;\n\n\t// Check if entire line content is deleted\n\tconst deletesEntireLineContent =\n\t\tstartPosition.lineNumber === endPosition.lineNumber &&\n\t\tstartPosition.column === 1 &&\n\t\tendPosition.column > lineContent.length;\n\n\treturn {\n\t\ttextShape,\n\t\tisAtEndOfLine,\n\t\tdeletesEntireLineContent,\n\t};\n}\n\nfunction computeReplaceProperties(oldText: string, newText: string): ReplaceProperties {\n\tconst oldShape = analyzeTextShape(oldText);\n\tconst newShape = analyzeTextShape(newText);\n\n\tconst oldIsWord = oldShape.kind === 'singleLine' && oldShape.isWord;\n\tconst newIsWord = newShape.kind === 'singleLine' && newShape.isWord;\n\tconst isWordToWordReplacement = oldIsWord && newIsWord;\n\n\tconst isAdditive = newText.length > oldText.length;\n\tconst isSubtractive = newText.length < oldText.length;\n\n\tconst isSingleLineToSingleLine = oldShape.kind === 'singleLine' && newShape.kind === 'singleLine';\n\tconst isSingleLineToMultiLine = oldShape.kind === 'singleLine' && newShape.kind === 'multiLine';\n\tconst isMultiLineToSingleLine = oldShape.kind === 'multiLine' && newShape.kind === 'singleLine';\n\n\treturn {\n\t\tisWordToWordReplacement,\n\t\tisAdditive,\n\t\tisSubtractive,\n\t\tisSingleLineToSingleLine,\n\t\tisSingleLineToMultiLine,\n\t\tisMultiLineToSingleLine,\n\t};\n}\n"]}