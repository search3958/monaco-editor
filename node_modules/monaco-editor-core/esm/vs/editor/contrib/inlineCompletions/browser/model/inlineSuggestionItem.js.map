{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/contrib/inlineCompletions/browser/model/inlineSuggestionItem.ts","vs/editor/contrib/inlineCompletions/browser/model/inlineSuggestionItem.ts"],"names":[],"mappings":"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","file":"inlineSuggestionItem.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { IObservable, ITransaction, observableSignal, observableValue } from '../../../../../base/common/observable.js';\nimport { commonPrefixLength, commonSuffixLength, splitLines } from '../../../../../base/common/strings.js';\nimport { ICommandService } from '../../../../../platform/commands/common/commands.js';\nimport { ISingleEditOperation } from '../../../../common/core/editOperation.js';\nimport { applyEditsToRanges, StringEdit, StringReplacement } from '../../../../common/core/edits/stringEdit.js';\nimport { TextEdit, TextReplacement } from '../../../../common/core/edits/textEdit.js';\nimport { Position } from '../../../../common/core/position.js';\nimport { Range } from '../../../../common/core/range.js';\nimport { OffsetRange } from '../../../../common/core/ranges/offsetRange.js';\nimport { StringText } from '../../../../common/core/text/abstractText.js';\nimport { getPositionOffsetTransformerFromTextModel } from '../../../../common/core/text/getPositionOffsetTransformerFromTextModel.js';\nimport { PositionOffsetTransformerBase } from '../../../../common/core/text/positionToOffset.js';\nimport { TextLength } from '../../../../common/core/text/textLength.js';\nimport { linesDiffComputers } from '../../../../common/diff/linesDiffComputers.js';\nimport { Command, IInlineCompletionHint, InlineCompletion, InlineCompletionEndOfLifeReason, InlineCompletionHintStyle, InlineCompletionTriggerKind, InlineCompletionWarning, PartialAcceptInfo } from '../../../../common/languages.js';\nimport { ITextModel } from '../../../../common/model.js';\nimport { TextModelText } from '../../../../common/model/textModelText.js';\nimport { InlineCompletionViewData, InlineCompletionViewKind } from '../view/inlineEdits/inlineEditsViewInterface.js';\nimport { computeEditKind, InlineSuggestionEditKind } from './editKind.js';\nimport { inlineCompletionIsVisible } from './inlineCompletionIsVisible.js';\nimport { IInlineSuggestDataAction, IInlineSuggestDataActionEdit, InlineSuggestData, InlineSuggestionList, PartialAcceptance, RenameInfo, SnippetInfo } from './provideInlineCompletions.js';\nimport { InlineSuggestAlternativeAction } from './InlineSuggestAlternativeAction.js';\nimport { TextModelValueReference } from './textModelValueReference.js';\n\nexport type InlineSuggestionItem = InlineEditItem | InlineCompletionItem;\n\nexport namespace InlineSuggestionItem {\n\texport function create(\n\t\tdata: InlineSuggestData,\n\t\ttextModel: TextModelValueReference,\n\t\tshouldDiffEdit: boolean = true, // TODO@benibenj it should only be created once and hence not meeded to be passed here\n\t): InlineSuggestionItem {\n\t\tif (!data.isInlineEdit && !data.action?.uri && data.action?.kind === 'edit') {\n\t\t\treturn InlineCompletionItem.create(data, textModel, data.action);\n\t\t} else {\n\t\t\treturn InlineEditItem.create(data, textModel, shouldDiffEdit);\n\t\t}\n\t}\n}\n\nexport type InlineSuggestionAction = IInlineSuggestionActionEdit | IInlineSuggestionActionJumpTo;\n\nexport interface IInlineSuggestionActionEdit {\n\tkind: 'edit';\n\ttextReplacement: TextReplacement;\n\tsnippetInfo: SnippetInfo | undefined;\n\tstringEdit: StringEdit;\n\ttarget: TextModelValueReference;\n\talternativeAction: InlineSuggestAlternativeAction | undefined;\n}\n\nexport interface IInlineSuggestionActionJumpTo {\n\tkind: 'jumpTo';\n\tposition: Position;\n\toffset: number;\n\ttarget: TextModelValueReference;\n}\n\nfunction hashInlineSuggestionAction(action: InlineSuggestionAction | undefined): string {\n\tconst obj = action?.kind === 'edit' ? {\n\t\t...action, alternativeAction: InlineSuggestAlternativeAction.toString(action.alternativeAction),\n\t\ttarget: action?.target.uri.toString(),\n\t} : {\n\t\t...action,\n\t\ttarget: action?.target.uri.toString(),\n\t};\n\n\treturn JSON.stringify(obj);\n}\n\nabstract class InlineSuggestionItemBase {\n\tconstructor(\n\t\tprotected readonly _data: InlineSuggestData,\n\t\tpublic readonly identity: InlineSuggestionIdentity,\n\t\tpublic readonly hint: InlineSuggestHint | undefined,\n\t\t/**\n\t\t * Reference to the text model this item targets.\n\t\t * For cross-file edits, this may differ from the current editor's model.\n\t\t */\n\t\tpublic readonly originalTextRef: TextModelValueReference,\n\t) {\n\t}\n\n\tpublic abstract get action(): InlineSuggestionAction | undefined;\n\n\t/**\n\t * A reference to the original inline completion list this inline completion has been constructed from.\n\t * Used for event data to ensure referential equality.\n\t*/\n\tpublic get source(): InlineSuggestionList { return this._data.source; }\n\n\tpublic get isFromExplicitRequest(): boolean { return this._data.context.triggerKind === InlineCompletionTriggerKind.Explicit; }\n\tpublic get forwardStable(): boolean { return this.source.inlineSuggestions.enableForwardStability ?? false; }\n\n\tpublic get targetRange(): Range {\n\t\tif (this.hint) {\n\t\t\treturn this.hint.range;\n\t\t}\n\t\tif (this.action?.kind === 'edit') {\n\t\t\treturn this.action.textReplacement.range;\n\t\t} else if (this.action?.kind === 'jumpTo') {\n\t\t\treturn Range.fromPositions(this.action.position);\n\t\t}\n\t\tthrow new BugIndicatingError('InlineSuggestionItem: Either hint or action must be set');\n\t}\n\n\tpublic get semanticId(): string { return this.hash; }\n\tpublic get gutterMenuLinkAction(): Command | undefined { return this._sourceInlineCompletion.gutterMenuLinkAction; }\n\tpublic get command(): Command | undefined { return this._sourceInlineCompletion.command; }\n\tpublic get supportsRename(): boolean { return this._data.supportsRename; }\n\tpublic get warning(): InlineCompletionWarning | undefined { return this._sourceInlineCompletion.warning; }\n\tpublic get showInlineEditMenu(): boolean { return !!this._sourceInlineCompletion.showInlineEditMenu; }\n\tpublic get hash(): string {\n\t\treturn hashInlineSuggestionAction(this.action);\n\t}\n\n\tpublic get requestUuid(): string { return this._data.context.requestUuid; }\n\n\tpublic get partialAccepts(): PartialAcceptance { return this._data.partialAccepts; }\n\n\t/**\n\t * A reference to the original inline completion this inline completion has been constructed from.\n\t * Used for event data to ensure referential equality.\n\t*/\n\tprivate get _sourceInlineCompletion(): InlineCompletion { return this._data.sourceInlineCompletion; }\n\n\n\tpublic abstract withEdit(userEdit: StringEdit, textModel: ITextModel): InlineSuggestionItem | undefined;\n\n\tpublic abstract withIdentity(identity: InlineSuggestionIdentity): InlineSuggestionItem;\n\tpublic abstract canBeReused(model: ITextModel, position: Position): boolean;\n\n\tpublic abstract computeEditKind(model: ITextModel): InlineSuggestionEditKind | undefined;\n\n\tpublic addRef(): void {\n\t\tthis.identity.addRef();\n\t\tthis.source.addRef();\n\t}\n\n\tpublic removeRef(): void {\n\t\tthis.identity.removeRef();\n\t\tthis.source.removeRef();\n\t}\n\n\tpublic reportInlineEditShown(commandService: ICommandService, viewKind: InlineCompletionViewKind, viewData: InlineCompletionViewData, model: ITextModel, timeWhenShown: number) {\n\t\tconst insertText = this.action?.kind === 'edit' ? this.action.textReplacement.text : ''; // TODO@hediet support insertText === undefined\n\t\tthis._data.reportInlineEditShown(commandService, insertText, viewKind, viewData, this.computeEditKind(model), timeWhenShown);\n\t}\n\n\tpublic reportPartialAccept(acceptedCharacters: number, info: PartialAcceptInfo, partialAcceptance: PartialAcceptance) {\n\t\tthis._data.reportPartialAccept(acceptedCharacters, info, partialAcceptance);\n\t}\n\n\tpublic reportEndOfLife(reason: InlineCompletionEndOfLifeReason): void {\n\t\tthis._data.reportEndOfLife(reason);\n\t}\n\n\tpublic setEndOfLifeReason(reason: InlineCompletionEndOfLifeReason): void {\n\t\tthis._data.setEndOfLifeReason(reason);\n\t}\n\n\tpublic setIsPreceeded(item: InlineSuggestionItem): void {\n\t\tthis._data.setIsPreceeded(item.partialAccepts);\n\t}\n\n\tpublic setNotShownReasonIfNotSet(reason: string): void {\n\t\tthis._data.setNotShownReason(reason);\n\t}\n\n\t/**\n\t * Avoid using this method. Instead introduce getters for the needed properties.\n\t*/\n\tpublic getSourceCompletion(): InlineCompletion {\n\t\treturn this._sourceInlineCompletion;\n\t}\n\n\tpublic setRenameProcessingInfo(info: RenameInfo): void {\n\t\tthis._data.setRenameProcessingInfo(info);\n\t}\n\n\tpublic withAction(action: IInlineSuggestDataAction): InlineSuggestData {\n\t\treturn this._data.withAction(action);\n\t}\n\n\tpublic addPerformanceMarker(marker: string): void {\n\t\tthis._data.addPerformanceMarker(marker);\n\t}\n}\n\nexport class InlineSuggestionIdentity {\n\tprivate static idCounter = 0;\n\tprivate readonly _onDispose = observableSignal(this);\n\tpublic readonly onDispose: IObservable<void> = this._onDispose;\n\n\tprivate readonly _jumpedTo = observableValue(this, false);\n\tpublic get jumpedTo(): IObservable<boolean> {\n\t\treturn this._jumpedTo;\n\t}\n\n\tprivate _refCount = 0;\n\tpublic readonly id = 'InlineCompletionIdentity' + InlineSuggestionIdentity.idCounter++;\n\n\taddRef() {\n\t\tthis._refCount++;\n\t}\n\n\tremoveRef() {\n\t\tthis._refCount--;\n\t\tif (this._refCount === 0) {\n\t\t\tthis._onDispose.trigger(undefined);\n\t\t}\n\t}\n\n\tsetJumpTo(tx: ITransaction | undefined): void {\n\t\tthis._jumpedTo.set(true, tx);\n\t}\n}\n\nexport class InlineSuggestHint {\n\n\tpublic static create(hint: IInlineCompletionHint) {\n\t\treturn new InlineSuggestHint(\n\t\t\tRange.lift(hint.range),\n\t\t\thint.content,\n\t\t\thint.style,\n\t\t);\n\t}\n\n\tprivate constructor(\n\t\tpublic readonly range: Range,\n\t\tpublic readonly content: string,\n\t\tpublic readonly style: InlineCompletionHintStyle,\n\t) { }\n\n\tpublic withEdit(edit: StringEdit, positionOffsetTransformer: PositionOffsetTransformerBase): InlineSuggestHint | undefined {\n\t\tconst offsetRange = new OffsetRange(\n\t\t\tpositionOffsetTransformer.getOffset(this.range.getStartPosition()),\n\t\t\tpositionOffsetTransformer.getOffset(this.range.getEndPosition())\n\t\t);\n\n\t\tconst newOffsetRange = applyEditsToRanges([offsetRange], edit)[0];\n\t\tif (!newOffsetRange) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst newRange = positionOffsetTransformer.getRange(newOffsetRange);\n\n\t\treturn new InlineSuggestHint(newRange, this.content, this.style);\n\t}\n}\n\nexport class InlineCompletionItem extends InlineSuggestionItemBase {\n\tpublic static create(\n\t\tdata: InlineSuggestData,\n\t\ttextModel: TextModelValueReference,\n\t\taction: IInlineSuggestDataActionEdit,\n\t): InlineCompletionItem {\n\t\tconst identity = new InlineSuggestionIdentity();\n\t\tconst transformer = textModel.getTransformer();\n\n\t\tconst insertText = action.insertText.replace(/\\r\\n|\\r|\\n/g, textModel.getEOL());\n\n\t\tconst edit = reshapeInlineCompletion(new StringReplacement(transformer.getOffsetRange(action.range), insertText), textModel);\n\t\tconst trimmedEdit = edit.removeCommonSuffixAndPrefix(textModel.getValue());\n\t\tconst textEdit = transformer.getTextReplacement(edit);\n\n\t\tconst displayLocation = data.hint ? InlineSuggestHint.create(data.hint) : undefined;\n\n\t\treturn new InlineCompletionItem(edit, trimmedEdit, textEdit, textEdit.range, action.snippetInfo, data.additionalTextEdits, data, identity, displayLocation, textModel);\n\t}\n\n\tpublic readonly isInlineEdit = false;\n\n\tprivate constructor(\n\t\tprivate readonly _edit: StringReplacement,\n\t\tprivate readonly _trimmedEdit: StringReplacement,\n\t\tprivate readonly _textEdit: TextReplacement,\n\t\tprivate readonly _originalRange: Range,\n\t\tpublic readonly snippetInfo: SnippetInfo | undefined,\n\t\tpublic readonly additionalTextEdits: readonly ISingleEditOperation[],\n\n\t\tdata: InlineSuggestData,\n\t\tidentity: InlineSuggestionIdentity,\n\t\tdisplayLocation: InlineSuggestHint | undefined,\n\t\toriginalTextRef: TextModelValueReference,\n\t) {\n\t\tsuper(data, identity, displayLocation, originalTextRef);\n\t}\n\n\toverride get action(): IInlineSuggestionActionEdit {\n\t\treturn {\n\t\t\tkind: 'edit',\n\t\t\ttextReplacement: this.getSingleTextEdit(),\n\t\t\tsnippetInfo: this.snippetInfo,\n\t\t\tstringEdit: new StringEdit([this._trimmedEdit]),\n\t\t\talternativeAction: undefined,\n\t\t\ttarget: this.originalTextRef,\n\t\t};\n\t}\n\n\toverride get hash(): string {\n\t\treturn JSON.stringify(this._trimmedEdit.toJson());\n\t}\n\n\tgetSingleTextEdit(): TextReplacement { return this._textEdit; }\n\n\toverride withIdentity(identity: InlineSuggestionIdentity): InlineCompletionItem {\n\t\treturn new InlineCompletionItem(\n\t\t\tthis._edit,\n\t\t\tthis._trimmedEdit,\n\t\t\tthis._textEdit,\n\t\t\tthis._originalRange,\n\t\t\tthis.snippetInfo,\n\t\t\tthis.additionalTextEdits,\n\t\t\tthis._data,\n\t\t\tidentity,\n\t\t\tthis.hint,\n\t\t\tthis.originalTextRef\n\t\t);\n\t}\n\n\toverride withEdit(textModelEdit: StringEdit, textModel: ITextModel): InlineCompletionItem | undefined {\n\t\t// If the edit is to a different model than our target, it's a noop\n\t\tif (!this.originalTextRef.targets(textModel)) {\n\t\t\treturn this;  // unchanged\n\t\t}\n\n\t\tconst newEditRange = applyEditsToRanges([this._edit.replaceRange], textModelEdit);\n\t\tif (newEditRange.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst newEdit = new StringReplacement(newEditRange[0], this._textEdit.text);\n\t\tconst positionOffsetTransformer = getPositionOffsetTransformerFromTextModel(textModel);\n\t\tconst newTextEdit = positionOffsetTransformer.getTextReplacement(newEdit);\n\n\t\tlet newDisplayLocation = this.hint;\n\t\tif (newDisplayLocation) {\n\t\t\tnewDisplayLocation = newDisplayLocation.withEdit(textModelEdit, positionOffsetTransformer);\n\t\t\tif (!newDisplayLocation) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\tconst trimmedEdit = newEdit.removeCommonSuffixAndPrefix(textModel.getValue());\n\n\t\treturn new InlineCompletionItem(\n\t\t\tnewEdit,\n\t\t\ttrimmedEdit,\n\t\t\tnewTextEdit,\n\t\t\tthis._originalRange,\n\t\t\tthis.snippetInfo,\n\t\t\tthis.additionalTextEdits,\n\t\t\tthis._data,\n\t\t\tthis.identity,\n\t\t\tnewDisplayLocation,\n\t\t\tthis.originalTextRef\n\t\t);\n\t}\n\n\toverride canBeReused(model: ITextModel, position: Position): boolean {\n\t\t// TODO@hediet I believe this can be simplified to `return true;`, as applying an edit should kick out this suggestion.\n\t\tconst updatedRange = this._textEdit.range;\n\t\tconst result = !!updatedRange\n\t\t\t&& updatedRange.containsPosition(position)\n\t\t\t&& this.isVisible(model, position)\n\t\t\t&& TextLength.ofRange(updatedRange).isGreaterThanOrEqualTo(TextLength.ofRange(this._originalRange));\n\t\treturn result;\n\t}\n\n\tpublic isVisible(model: ITextModel, cursorPosition: Position): boolean {\n\t\tconst singleTextEdit = this.getSingleTextEdit();\n\t\treturn inlineCompletionIsVisible(singleTextEdit, this._originalRange, model, cursorPosition);\n\t}\n\n\toverride computeEditKind(model: ITextModel): InlineSuggestionEditKind | undefined {\n\t\treturn computeEditKind(new StringEdit([this._edit]), model);\n\t}\n\n\tpublic get editRange(): Range { return this.getSingleTextEdit().range; }\n}\n\nexport class InlineEditItem extends InlineSuggestionItemBase {\n\n\tpublic static create(\n\t\tdata: InlineSuggestData,\n\t\ttextModel: TextModelValueReference,\n\t\tshouldDiffEdit: boolean = true,\n\t): InlineEditItem {\n\t\tlet action: InlineSuggestionAction | undefined;\n\t\tlet edits: SingleUpdatedNextEdit[] = [];\n\t\tif (data.action?.kind === 'edit') {\n\t\t\tconst offsetEdit = shouldDiffEdit ? getDiffedStringEdit(textModel, data.action.range, data.action.insertText) : getStringEdit(textModel, data.action.range, data.action.insertText); // TODO compute async\n\t\t\tconst textEdit = TextEdit.fromStringEdit(offsetEdit, textModel);\n\t\t\tconst singleTextEdit = offsetEdit.isEmpty() ? new TextReplacement(new Range(1, 1, 1, 1), '') : textEdit.toReplacement(textModel); // FIXME: .toReplacement() can throw because offsetEdit is empty because we get an empty diff in getStringEdit after diffing\n\n\t\t\tedits = offsetEdit.replacements.map(edit => {\n\t\t\t\tconst replacedRange = Range.fromPositions(textModel.getPositionAt(edit.replaceRange.start), textModel.getTransformer().getPosition(edit.replaceRange.endExclusive));\n\t\t\t\tconst replacedText = textModel.getValueInRange(replacedRange);\n\t\t\t\treturn SingleUpdatedNextEdit.create(edit, replacedText);\n\t\t\t});\n\n\t\t\taction = {\n\t\t\t\tkind: 'edit',\n\t\t\t\tsnippetInfo: data.action.snippetInfo,\n\t\t\t\tstringEdit: offsetEdit,\n\t\t\t\ttextReplacement: singleTextEdit,\n\t\t\t\talternativeAction: data.action.alternativeAction,\n\t\t\t\ttarget: textModel,\n\t\t\t};\n\t\t} else if (data.action?.kind === 'jumpTo') {\n\t\t\taction = {\n\t\t\t\tkind: 'jumpTo',\n\t\t\t\tposition: data.action.position,\n\t\t\t\toffset: textModel.getTransformer().getOffset(data.action.position),\n\t\t\t\ttarget: textModel,\n\t\t\t};\n\t\t} else {\n\t\t\taction = undefined;\n\t\t\tif (!data.hint) {\n\t\t\t\tthrow new BugIndicatingError('InlineEditItem: action is undefined and no hint is provided');\n\t\t\t}\n\t\t}\n\n\t\tconst identity = new InlineSuggestionIdentity();\n\n\t\tconst hint = data.hint ? InlineSuggestHint.create(data.hint) : undefined;\n\t\treturn new InlineEditItem(action, data, identity, edits, hint, false, textModel.getVersionId(), textModel);\n\t}\n\n\tpublic readonly snippetInfo: SnippetInfo | undefined = undefined;\n\tpublic readonly additionalTextEdits: readonly ISingleEditOperation[] = [];\n\tpublic readonly isInlineEdit = true;\n\n\tprivate constructor(\n\t\tprivate readonly _action: InlineSuggestionAction | undefined,\n\n\t\tdata: InlineSuggestData,\n\n\t\tidentity: InlineSuggestionIdentity,\n\t\tprivate readonly _edits: readonly SingleUpdatedNextEdit[],\n\t\thint: InlineSuggestHint | undefined,\n\t\tprivate readonly _lastChangePartOfInlineEdit = false,\n\t\tprivate readonly _inlineEditModelVersion: number,\n\t\toriginalTextRef: TextModelValueReference,\n\t) {\n\t\tsuper(data, identity, hint, originalTextRef);\n\t}\n\n\tpublic get updatedEditModelVersion(): number { return this._inlineEditModelVersion; }\n\t// public get updatedEdit(): StringEdit { return this._edit; }\n\n\toverride get action(): InlineSuggestionAction | undefined {\n\t\treturn this._action;\n\t}\n\n\toverride withIdentity(identity: InlineSuggestionIdentity): InlineEditItem {\n\t\treturn new InlineEditItem(\n\t\t\tthis._action,\n\t\t\tthis._data,\n\t\t\tidentity,\n\t\t\tthis._edits,\n\t\t\tthis.hint,\n\t\t\tthis._lastChangePartOfInlineEdit,\n\t\t\tthis._inlineEditModelVersion,\n\t\t\tthis.originalTextRef,\n\t\t);\n\t}\n\n\toverride canBeReused(model: ITextModel, position: Position): boolean {\n\t\t// TODO@hediet I believe this can be simplified to `return true;`, as applying an edit should kick out this suggestion.\n\t\treturn this._lastChangePartOfInlineEdit && this.updatedEditModelVersion === model.getVersionId();\n\t}\n\n\toverride withEdit(textModelChanges: StringEdit, textModel: ITextModel): InlineEditItem | undefined {\n\t\t// If the edit is to a different model than our target, it's a noop\n\t\tif (!this.originalTextRef.targets(textModel)) {\n\t\t\treturn this;  // unchanged\n\t\t}\n\n\t\tconst edit = this._applyTextModelChanges(textModelChanges, this._edits, textModel);\n\t\treturn edit;\n\t}\n\n\tprivate _applyTextModelChanges(textModelChanges: StringEdit, edits: readonly SingleUpdatedNextEdit[], textModel: ITextModel): InlineEditItem | undefined {\n\t\tconst positionOffsetTransformer = getPositionOffsetTransformerFromTextModel(textModel);\n\n\t\tlet lastChangePartOfInlineEdit = false;\n\t\tlet inlineEditModelVersion = this._inlineEditModelVersion;\n\t\tlet newAction: InlineSuggestionAction | undefined;\n\n\t\tif (this.action?.kind === 'edit') { // TODO What about rename?\n\t\t\tedits = edits.map(innerEdit => innerEdit.applyTextModelChanges(textModelChanges));\n\n\t\t\tif (edits.some(edit => edit.edit === undefined)) {\n\t\t\t\treturn undefined; // change is invalid, so we will have to drop the completion\n\t\t\t}\n\n\n\t\t\tconst newTextModelVersion = textModel.getVersionId();\n\t\t\tlastChangePartOfInlineEdit = edits.some(edit => edit.lastChangeUpdatedEdit);\n\t\t\tif (lastChangePartOfInlineEdit) {\n\t\t\t\tinlineEditModelVersion = newTextModelVersion ?? -1;\n\t\t\t}\n\n\t\t\tif (newTextModelVersion === null || inlineEditModelVersion + 20 < newTextModelVersion) {\n\t\t\t\treturn undefined; // the completion has been ignored for a while, remove it\n\t\t\t}\n\n\t\t\tedits = edits.filter(innerEdit => !innerEdit.edit!.isEmpty);\n\t\t\tif (edits.length === 0) {\n\t\t\t\treturn undefined; // the completion has been typed by the user\n\t\t\t}\n\n\t\t\tconst newEdit = new StringEdit(edits.map(edit => edit.edit!));\n\n\t\t\tconst newTextEdit = positionOffsetTransformer.getTextEdit(newEdit).toReplacement(new TextModelText(textModel));\n\n\t\t\tnewAction = {\n\t\t\t\tkind: 'edit',\n\t\t\t\ttextReplacement: newTextEdit,\n\t\t\t\tsnippetInfo: this.snippetInfo,\n\t\t\t\tstringEdit: newEdit,\n\t\t\t\talternativeAction: this.action.alternativeAction,\n\t\t\t\ttarget: this.originalTextRef,\n\t\t\t};\n\t\t} else if (this.action?.kind === 'jumpTo') {\n\t\t\tconst jumpToOffset = this.action.offset;\n\t\t\tconst newJumpToOffset = textModelChanges.applyToOffsetOrUndefined(jumpToOffset);\n\t\t\tif (newJumpToOffset === undefined) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tconst newJumpToPosition = positionOffsetTransformer.getPosition(newJumpToOffset);\n\n\t\t\tnewAction = {\n\t\t\t\tkind: 'jumpTo',\n\t\t\t\tposition: newJumpToPosition,\n\t\t\t\toffset: newJumpToOffset,\n\t\t\t\ttarget: this.originalTextRef,\n\t\t\t};\n\t\t} else {\n\t\t\tnewAction = undefined;\n\t\t}\n\n\t\tlet newDisplayLocation = this.hint;\n\t\tif (newDisplayLocation) {\n\t\t\tnewDisplayLocation = newDisplayLocation.withEdit(textModelChanges, positionOffsetTransformer);\n\t\t\tif (!newDisplayLocation) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\treturn new InlineEditItem(\n\t\t\tnewAction,\n\t\t\tthis._data,\n\t\t\tthis.identity,\n\t\t\tedits,\n\t\t\tnewDisplayLocation,\n\t\t\tlastChangePartOfInlineEdit,\n\t\t\tinlineEditModelVersion,\n\t\t\tthis.originalTextRef,\n\t\t);\n\t}\n\n\toverride computeEditKind(model: ITextModel): InlineSuggestionEditKind | undefined {\n\t\tconst edit = this.action?.kind === 'edit' ? this.action.stringEdit : undefined;\n\t\tif (!edit) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn computeEditKind(edit, model);\n\t}\n}\n\nfunction getDiffedStringEdit(textModel: TextModelValueReference, editRange: Range, replaceText: string): StringEdit {\n\tconst eol = textModel.getEOL();\n\tconst editOriginalText = textModel.getValueOfRange(editRange);\n\tconst editReplaceText = replaceText.replace(/\\r\\n|\\r|\\n/g, eol);\n\n\tconst diffAlgorithm = linesDiffComputers.getDefault();\n\tconst lineDiffs = diffAlgorithm.computeDiff(\n\t\tsplitLines(editOriginalText),\n\t\tsplitLines(editReplaceText),\n\t\t{\n\t\t\tignoreTrimWhitespace: false,\n\t\t\tcomputeMoves: false,\n\t\t\textendToSubwords: true,\n\t\t\tmaxComputationTimeMs: 50,\n\t\t}\n\t);\n\n\tconst innerChanges = lineDiffs.changes.flatMap(c => c.innerChanges ?? []);\n\n\tfunction addRangeToPos(pos: Position, range: Range): Range {\n\t\tconst start = TextLength.fromPosition(range.getStartPosition());\n\t\treturn TextLength.ofRange(range).createRange(start.addToPosition(pos));\n\t}\n\n\tconst modifiedText = new StringText(editReplaceText);\n\n\tconst offsetEdit = new StringEdit(\n\t\tinnerChanges.map(c => {\n\t\t\tconst rangeInModel = addRangeToPos(editRange.getStartPosition(), c.originalRange);\n\t\t\tconst originalRange = textModel.getTransformer().getOffsetRange(rangeInModel);\n\n\t\t\tconst replaceText = modifiedText.getValueOfRange(c.modifiedRange);\n\t\t\tconst edit = new StringReplacement(originalRange, replaceText);\n\n\t\t\tconst originalText = textModel.getValueOfRange(rangeInModel);\n\t\t\treturn reshapeInlineEdit(edit, originalText, innerChanges.length, textModel);\n\t\t})\n\t);\n\n\treturn offsetEdit;\n}\n\nfunction getStringEdit(textModel: TextModelValueReference, editRange: Range, replaceText: string): StringEdit {\n\treturn new StringEdit([new StringReplacement(\n\t\ttextModel.getTransformer().getOffsetRange(editRange),\n\t\treplaceText\n\t)]);\n}\n\nclass SingleUpdatedNextEdit {\n\tpublic static create(\n\t\tedit: StringReplacement,\n\t\treplacedText: string,\n\t): SingleUpdatedNextEdit {\n\t\tconst prefixLength = commonPrefixLength(edit.newText, replacedText);\n\t\tconst suffixLength = commonSuffixLength(edit.newText, replacedText);\n\t\tconst trimmedNewText = edit.newText.substring(prefixLength, edit.newText.length - suffixLength);\n\t\treturn new SingleUpdatedNextEdit(edit, trimmedNewText, prefixLength, suffixLength);\n\t}\n\n\tpublic get edit() { return this._edit; }\n\tpublic get lastChangeUpdatedEdit() { return this._lastChangeUpdatedEdit; }\n\n\tconstructor(\n\t\tprivate _edit: StringReplacement | undefined,\n\t\tprivate _trimmedNewText: string,\n\t\tprivate _prefixLength: number,\n\t\tprivate _suffixLength: number,\n\t\tprivate _lastChangeUpdatedEdit: boolean = false,\n\t) {\n\t}\n\n\tpublic applyTextModelChanges(textModelChanges: StringEdit) {\n\t\tconst c = this._clone();\n\t\tc._applyTextModelChanges(textModelChanges);\n\t\treturn c;\n\t}\n\n\tprivate _clone(): SingleUpdatedNextEdit {\n\t\treturn new SingleUpdatedNextEdit(\n\t\t\tthis._edit,\n\t\t\tthis._trimmedNewText,\n\t\t\tthis._prefixLength,\n\t\t\tthis._suffixLength,\n\t\t\tthis._lastChangeUpdatedEdit,\n\t\t);\n\t}\n\n\tprivate _applyTextModelChanges(textModelChanges: StringEdit) {\n\t\tthis._lastChangeUpdatedEdit = false; // TODO @benibenj make immutable\n\n\t\tif (!this._edit) {\n\t\t\tthrow new BugIndicatingError('UpdatedInnerEdits: No edit to apply changes to');\n\t\t}\n\n\t\tconst result = this._applyChanges(this._edit, textModelChanges);\n\t\tif (!result) {\n\t\t\tthis._edit = undefined;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._edit = result.edit;\n\t\tthis._lastChangeUpdatedEdit = result.editHasChanged;\n\t}\n\n\tprivate _applyChanges(edit: StringReplacement, textModelChanges: StringEdit): { edit: StringReplacement; editHasChanged: boolean } | undefined {\n\t\tlet editStart = edit.replaceRange.start;\n\t\tlet editEnd = edit.replaceRange.endExclusive;\n\t\tlet editReplaceText = edit.newText;\n\t\tlet editHasChanged = false;\n\n\t\tconst shouldPreserveEditShape = this._prefixLength > 0 || this._suffixLength > 0;\n\n\t\tfor (let i = textModelChanges.replacements.length - 1; i >= 0; i--) {\n\t\t\tconst change = textModelChanges.replacements[i];\n\n\t\t\t// INSERTIONS (only support inserting at start of edit)\n\t\t\tconst isInsertion = change.newText.length > 0 && change.replaceRange.isEmpty;\n\n\t\t\tif (isInsertion && !shouldPreserveEditShape && change.replaceRange.start === editStart && editReplaceText.startsWith(change.newText)) {\n\t\t\t\teditStart += change.newText.length;\n\t\t\t\teditReplaceText = editReplaceText.substring(change.newText.length);\n\t\t\t\teditEnd += change.newText.length;\n\t\t\t\teditHasChanged = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (isInsertion && shouldPreserveEditShape && change.replaceRange.start === editStart + this._prefixLength && this._trimmedNewText.startsWith(change.newText)) {\n\t\t\t\teditEnd += change.newText.length;\n\t\t\t\teditHasChanged = true;\n\t\t\t\tthis._prefixLength += change.newText.length;\n\t\t\t\tthis._trimmedNewText = this._trimmedNewText.substring(change.newText.length);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// DELETIONS\n\t\t\tconst isDeletion = change.newText.length === 0 && change.replaceRange.length > 0;\n\t\t\tif (isDeletion && change.replaceRange.start >= editStart + this._prefixLength && change.replaceRange.endExclusive <= editEnd - this._suffixLength) {\n\t\t\t\t// user deleted text IN-BETWEEN the deletion range\n\t\t\t\teditEnd -= change.replaceRange.length;\n\t\t\t\teditHasChanged = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// user did exactly the edit\n\t\t\tif (change.equals(edit)) {\n\t\t\t\teditHasChanged = true;\n\t\t\t\teditStart = change.replaceRange.endExclusive;\n\t\t\t\teditReplaceText = '';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// MOVE EDIT\n\t\t\tif (change.replaceRange.start > editEnd) {\n\t\t\t\t// the change happens after the completion range\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (change.replaceRange.endExclusive < editStart) {\n\t\t\t\t// the change happens before the completion range\n\t\t\t\teditStart += change.newText.length - change.replaceRange.length;\n\t\t\t\teditEnd += change.newText.length - change.replaceRange.length;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// The change intersects the completion, so we will have to drop the completion\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// the resulting edit is a noop as the original and new text are the same\n\t\tif (this._trimmedNewText.length === 0 && editStart + this._prefixLength === editEnd - this._suffixLength) {\n\t\t\treturn { edit: new StringReplacement(new OffsetRange(editStart + this._prefixLength, editStart + this._prefixLength), ''), editHasChanged: true };\n\t\t}\n\n\t\treturn { edit: new StringReplacement(new OffsetRange(editStart, editEnd), editReplaceText), editHasChanged };\n\t}\n}\n\nfunction reshapeInlineCompletion(edit: StringReplacement, textModel: TextModelValueReference): StringReplacement {\n\t// If the insertion is a multi line insertion starting on the next line\n\t// Move it forwards so that the multi line insertion starts on the current line\n\tconst eol = textModel.getEOL();\n\tif (edit.replaceRange.isEmpty && edit.newText.includes(eol)) {\n\t\tedit = reshapeMultiLineInsertion(edit, textModel);\n\t}\n\n\treturn edit;\n}\n\nfunction reshapeInlineEdit(edit: StringReplacement, originalText: string, totalInnerEdits: number, textModel: TextModelValueReference): StringReplacement {\n\t// TODO: EOL are not properly trimmed by the diffAlgorithm #12680\n\tconst eol = textModel.getEOL();\n\tif (edit.newText.endsWith(eol) && originalText.endsWith(eol)) {\n\t\tedit = new StringReplacement(edit.replaceRange.deltaEnd(-eol.length), edit.newText.slice(0, -eol.length));\n\t}\n\n\t// INSERTION\n\t// If the insertion ends with a new line and is inserted at the start of a line which has text,\n\t// we move the insertion to the end of the previous line if possible\n\tif (totalInnerEdits === 1 && edit.replaceRange.isEmpty && edit.newText.includes(eol)) {\n\t\tconst startPosition = textModel.getTransformer().getPosition(edit.replaceRange.start);\n\t\tconst hasTextOnInsertionLine = textModel.getLineLength(startPosition.lineNumber) !== 0;\n\t\tif (hasTextOnInsertionLine) {\n\t\t\tedit = reshapeMultiLineInsertion(edit, textModel);\n\t\t}\n\t}\n\n\t// The diff algorithm extended a simple edit to the entire word\n\t// shrink it back to a simple edit if it is deletion/insertion only\n\tif (totalInnerEdits === 1) {\n\t\tconst prefixLength = commonPrefixLength(originalText, edit.newText);\n\t\tconst suffixLength = commonSuffixLength(originalText.slice(prefixLength), edit.newText.slice(prefixLength));\n\n\t\t// reshape it back to an insertion\n\t\tif (prefixLength + suffixLength === originalText.length) {\n\t\t\treturn new StringReplacement(edit.replaceRange.deltaStart(prefixLength).deltaEnd(-suffixLength), edit.newText.substring(prefixLength, edit.newText.length - suffixLength));\n\t\t}\n\n\t\t// reshape it back to a deletion\n\t\tif (prefixLength + suffixLength === edit.newText.length) {\n\t\t\treturn new StringReplacement(edit.replaceRange.deltaStart(prefixLength).deltaEnd(-suffixLength), '');\n\t\t}\n\t}\n\n\treturn edit;\n}\n\nfunction reshapeMultiLineInsertion(edit: StringReplacement, textModel: TextModelValueReference): StringReplacement {\n\tif (!edit.replaceRange.isEmpty) {\n\t\tthrow new BugIndicatingError('Unexpected original range');\n\t}\n\n\tif (edit.replaceRange.start === 0) {\n\t\treturn edit;\n\t}\n\n\tconst eol = textModel.getEOL();\n\tconst startPosition = textModel.getTransformer().getPosition(edit.replaceRange.start);\n\tconst startColumn = startPosition.column;\n\tconst startLineNumber = startPosition.lineNumber;\n\n\t// If the insertion ends with a new line and is inserted at the start of a line which has text,\n\t// we move the insertion to the end of the previous line if possible\n\tif (startColumn === 1 && startLineNumber > 1 && edit.newText.endsWith(eol) && !edit.newText.startsWith(eol)) {\n\t\treturn new StringReplacement(edit.replaceRange.delta(-1), eol + edit.newText.slice(0, -eol.length));\n\t}\n\n\treturn edit;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { IObservable, ITransaction, observableSignal, observableValue } from '../../../../../base/common/observable.js';\nimport { commonPrefixLength, commonSuffixLength, splitLines } from '../../../../../base/common/strings.js';\nimport { ICommandService } from '../../../../../platform/commands/common/commands.js';\nimport { ISingleEditOperation } from '../../../../common/core/editOperation.js';\nimport { applyEditsToRanges, StringEdit, StringReplacement } from '../../../../common/core/edits/stringEdit.js';\nimport { TextEdit, TextReplacement } from '../../../../common/core/edits/textEdit.js';\nimport { Position } from '../../../../common/core/position.js';\nimport { Range } from '../../../../common/core/range.js';\nimport { OffsetRange } from '../../../../common/core/ranges/offsetRange.js';\nimport { StringText } from '../../../../common/core/text/abstractText.js';\nimport { getPositionOffsetTransformerFromTextModel } from '../../../../common/core/text/getPositionOffsetTransformerFromTextModel.js';\nimport { PositionOffsetTransformerBase } from '../../../../common/core/text/positionToOffset.js';\nimport { TextLength } from '../../../../common/core/text/textLength.js';\nimport { linesDiffComputers } from '../../../../common/diff/linesDiffComputers.js';\nimport { Command, IInlineCompletionHint, InlineCompletion, InlineCompletionEndOfLifeReason, InlineCompletionHintStyle, InlineCompletionTriggerKind, InlineCompletionWarning, PartialAcceptInfo } from '../../../../common/languages.js';\nimport { ITextModel } from '../../../../common/model.js';\nimport { TextModelText } from '../../../../common/model/textModelText.js';\nimport { InlineCompletionViewData, InlineCompletionViewKind } from '../view/inlineEdits/inlineEditsViewInterface.js';\nimport { computeEditKind, InlineSuggestionEditKind } from './editKind.js';\nimport { inlineCompletionIsVisible } from './inlineCompletionIsVisible.js';\nimport { IInlineSuggestDataAction, IInlineSuggestDataActionEdit, InlineSuggestData, InlineSuggestionList, PartialAcceptance, RenameInfo, SnippetInfo } from './provideInlineCompletions.js';\nimport { InlineSuggestAlternativeAction } from './InlineSuggestAlternativeAction.js';\nimport { TextModelValueReference } from './textModelValueReference.js';\n\nexport type InlineSuggestionItem = InlineEditItem | InlineCompletionItem;\n\nexport namespace InlineSuggestionItem {\n\texport function create(\n\t\tdata: InlineSuggestData,\n\t\ttextModel: TextModelValueReference,\n\t\tshouldDiffEdit: boolean = true, // TODO@benibenj it should only be created once and hence not meeded to be passed here\n\t): InlineSuggestionItem {\n\t\tif (!data.isInlineEdit && !data.action?.uri && data.action?.kind === 'edit') {\n\t\t\treturn InlineCompletionItem.create(data, textModel, data.action);\n\t\t} else {\n\t\t\treturn InlineEditItem.create(data, textModel, shouldDiffEdit);\n\t\t}\n\t}\n}\n\nexport type InlineSuggestionAction = IInlineSuggestionActionEdit | IInlineSuggestionActionJumpTo;\n\nexport interface IInlineSuggestionActionEdit {\n\tkind: 'edit';\n\ttextReplacement: TextReplacement;\n\tsnippetInfo: SnippetInfo | undefined;\n\tstringEdit: StringEdit;\n\ttarget: TextModelValueReference;\n\talternativeAction: InlineSuggestAlternativeAction | undefined;\n}\n\nexport interface IInlineSuggestionActionJumpTo {\n\tkind: 'jumpTo';\n\tposition: Position;\n\toffset: number;\n\ttarget: TextModelValueReference;\n}\n\nfunction hashInlineSuggestionAction(action: InlineSuggestionAction | undefined): string {\n\tconst obj = action?.kind === 'edit' ? {\n\t\t...action, alternativeAction: InlineSuggestAlternativeAction.toString(action.alternativeAction),\n\t\ttarget: action?.target.uri.toString(),\n\t} : {\n\t\t...action,\n\t\ttarget: action?.target.uri.toString(),\n\t};\n\n\treturn JSON.stringify(obj);\n}\n\nabstract class InlineSuggestionItemBase {\n\tconstructor(\n\t\tprotected readonly _data: InlineSuggestData,\n\t\tpublic readonly identity: InlineSuggestionIdentity,\n\t\tpublic readonly hint: InlineSuggestHint | undefined,\n\t\t/**\n\t\t * Reference to the text model this item targets.\n\t\t * For cross-file edits, this may differ from the current editor's model.\n\t\t */\n\t\tpublic readonly originalTextRef: TextModelValueReference,\n\t) {\n\t}\n\n\tpublic abstract get action(): InlineSuggestionAction | undefined;\n\n\t/**\n\t * A reference to the original inline completion list this inline completion has been constructed from.\n\t * Used for event data to ensure referential equality.\n\t*/\n\tpublic get source(): InlineSuggestionList { return this._data.source; }\n\n\tpublic get isFromExplicitRequest(): boolean { return this._data.context.triggerKind === InlineCompletionTriggerKind.Explicit; }\n\tpublic get forwardStable(): boolean { return this.source.inlineSuggestions.enableForwardStability ?? false; }\n\n\tpublic get targetRange(): Range {\n\t\tif (this.hint) {\n\t\t\treturn this.hint.range;\n\t\t}\n\t\tif (this.action?.kind === 'edit') {\n\t\t\treturn this.action.textReplacement.range;\n\t\t} else if (this.action?.kind === 'jumpTo') {\n\t\t\treturn Range.fromPositions(this.action.position);\n\t\t}\n\t\tthrow new BugIndicatingError('InlineSuggestionItem: Either hint or action must be set');\n\t}\n\n\tpublic get semanticId(): string { return this.hash; }\n\tpublic get gutterMenuLinkAction(): Command | undefined { return this._sourceInlineCompletion.gutterMenuLinkAction; }\n\tpublic get command(): Command | undefined { return this._sourceInlineCompletion.command; }\n\tpublic get supportsRename(): boolean { return this._data.supportsRename; }\n\tpublic get warning(): InlineCompletionWarning | undefined { return this._sourceInlineCompletion.warning; }\n\tpublic get showInlineEditMenu(): boolean { return !!this._sourceInlineCompletion.showInlineEditMenu; }\n\tpublic get hash(): string {\n\t\treturn hashInlineSuggestionAction(this.action);\n\t}\n\n\tpublic get requestUuid(): string { return this._data.context.requestUuid; }\n\n\tpublic get partialAccepts(): PartialAcceptance { return this._data.partialAccepts; }\n\n\t/**\n\t * A reference to the original inline completion this inline completion has been constructed from.\n\t * Used for event data to ensure referential equality.\n\t*/\n\tprivate get _sourceInlineCompletion(): InlineCompletion { return this._data.sourceInlineCompletion; }\n\n\n\tpublic abstract withEdit(userEdit: StringEdit, textModel: ITextModel): InlineSuggestionItem | undefined;\n\n\tpublic abstract withIdentity(identity: InlineSuggestionIdentity): InlineSuggestionItem;\n\tpublic abstract canBeReused(model: ITextModel, position: Position): boolean;\n\n\tpublic abstract computeEditKind(model: ITextModel): InlineSuggestionEditKind | undefined;\n\n\tpublic addRef(): void {\n\t\tthis.identity.addRef();\n\t\tthis.source.addRef();\n\t}\n\n\tpublic removeRef(): void {\n\t\tthis.identity.removeRef();\n\t\tthis.source.removeRef();\n\t}\n\n\tpublic reportInlineEditShown(commandService: ICommandService, viewKind: InlineCompletionViewKind, viewData: InlineCompletionViewData, model: ITextModel, timeWhenShown: number) {\n\t\tconst insertText = this.action?.kind === 'edit' ? this.action.textReplacement.text : ''; // TODO@hediet support insertText === undefined\n\t\tthis._data.reportInlineEditShown(commandService, insertText, viewKind, viewData, this.computeEditKind(model), timeWhenShown);\n\t}\n\n\tpublic reportPartialAccept(acceptedCharacters: number, info: PartialAcceptInfo, partialAcceptance: PartialAcceptance) {\n\t\tthis._data.reportPartialAccept(acceptedCharacters, info, partialAcceptance);\n\t}\n\n\tpublic reportEndOfLife(reason: InlineCompletionEndOfLifeReason): void {\n\t\tthis._data.reportEndOfLife(reason);\n\t}\n\n\tpublic setEndOfLifeReason(reason: InlineCompletionEndOfLifeReason): void {\n\t\tthis._data.setEndOfLifeReason(reason);\n\t}\n\n\tpublic setIsPreceeded(item: InlineSuggestionItem): void {\n\t\tthis._data.setIsPreceeded(item.partialAccepts);\n\t}\n\n\tpublic setNotShownReasonIfNotSet(reason: string): void {\n\t\tthis._data.setNotShownReason(reason);\n\t}\n\n\t/**\n\t * Avoid using this method. Instead introduce getters for the needed properties.\n\t*/\n\tpublic getSourceCompletion(): InlineCompletion {\n\t\treturn this._sourceInlineCompletion;\n\t}\n\n\tpublic setRenameProcessingInfo(info: RenameInfo): void {\n\t\tthis._data.setRenameProcessingInfo(info);\n\t}\n\n\tpublic withAction(action: IInlineSuggestDataAction): InlineSuggestData {\n\t\treturn this._data.withAction(action);\n\t}\n\n\tpublic addPerformanceMarker(marker: string): void {\n\t\tthis._data.addPerformanceMarker(marker);\n\t}\n}\n\nexport class InlineSuggestionIdentity {\n\tprivate static idCounter = 0;\n\tprivate readonly _onDispose = observableSignal(this);\n\tpublic readonly onDispose: IObservable<void> = this._onDispose;\n\n\tprivate readonly _jumpedTo = observableValue(this, false);\n\tpublic get jumpedTo(): IObservable<boolean> {\n\t\treturn this._jumpedTo;\n\t}\n\n\tprivate _refCount = 0;\n\tpublic readonly id = 'InlineCompletionIdentity' + InlineSuggestionIdentity.idCounter++;\n\n\taddRef() {\n\t\tthis._refCount++;\n\t}\n\n\tremoveRef() {\n\t\tthis._refCount--;\n\t\tif (this._refCount === 0) {\n\t\t\tthis._onDispose.trigger(undefined);\n\t\t}\n\t}\n\n\tsetJumpTo(tx: ITransaction | undefined): void {\n\t\tthis._jumpedTo.set(true, tx);\n\t}\n}\n\nexport class InlineSuggestHint {\n\n\tpublic static create(hint: IInlineCompletionHint) {\n\t\treturn new InlineSuggestHint(\n\t\t\tRange.lift(hint.range),\n\t\t\thint.content,\n\t\t\thint.style,\n\t\t);\n\t}\n\n\tprivate constructor(\n\t\tpublic readonly range: Range,\n\t\tpublic readonly content: string,\n\t\tpublic readonly style: InlineCompletionHintStyle,\n\t) { }\n\n\tpublic withEdit(edit: StringEdit, positionOffsetTransformer: PositionOffsetTransformerBase): InlineSuggestHint | undefined {\n\t\tconst offsetRange = new OffsetRange(\n\t\t\tpositionOffsetTransformer.getOffset(this.range.getStartPosition()),\n\t\t\tpositionOffsetTransformer.getOffset(this.range.getEndPosition())\n\t\t);\n\n\t\tconst newOffsetRange = applyEditsToRanges([offsetRange], edit)[0];\n\t\tif (!newOffsetRange) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst newRange = positionOffsetTransformer.getRange(newOffsetRange);\n\n\t\treturn new InlineSuggestHint(newRange, this.content, this.style);\n\t}\n}\n\nexport class InlineCompletionItem extends InlineSuggestionItemBase {\n\tpublic static create(\n\t\tdata: InlineSuggestData,\n\t\ttextModel: TextModelValueReference,\n\t\taction: IInlineSuggestDataActionEdit,\n\t): InlineCompletionItem {\n\t\tconst identity = new InlineSuggestionIdentity();\n\t\tconst transformer = textModel.getTransformer();\n\n\t\tconst insertText = action.insertText.replace(/\\r\\n|\\r|\\n/g, textModel.getEOL());\n\n\t\tconst edit = reshapeInlineCompletion(new StringReplacement(transformer.getOffsetRange(action.range), insertText), textModel);\n\t\tconst trimmedEdit = edit.removeCommonSuffixAndPrefix(textModel.getValue());\n\t\tconst textEdit = transformer.getTextReplacement(edit);\n\n\t\tconst displayLocation = data.hint ? InlineSuggestHint.create(data.hint) : undefined;\n\n\t\treturn new InlineCompletionItem(edit, trimmedEdit, textEdit, textEdit.range, action.snippetInfo, data.additionalTextEdits, data, identity, displayLocation, textModel);\n\t}\n\n\tpublic readonly isInlineEdit = false;\n\n\tprivate constructor(\n\t\tprivate readonly _edit: StringReplacement,\n\t\tprivate readonly _trimmedEdit: StringReplacement,\n\t\tprivate readonly _textEdit: TextReplacement,\n\t\tprivate readonly _originalRange: Range,\n\t\tpublic readonly snippetInfo: SnippetInfo | undefined,\n\t\tpublic readonly additionalTextEdits: readonly ISingleEditOperation[],\n\n\t\tdata: InlineSuggestData,\n\t\tidentity: InlineSuggestionIdentity,\n\t\tdisplayLocation: InlineSuggestHint | undefined,\n\t\toriginalTextRef: TextModelValueReference,\n\t) {\n\t\tsuper(data, identity, displayLocation, originalTextRef);\n\t}\n\n\toverride get action(): IInlineSuggestionActionEdit {\n\t\treturn {\n\t\t\tkind: 'edit',\n\t\t\ttextReplacement: this.getSingleTextEdit(),\n\t\t\tsnippetInfo: this.snippetInfo,\n\t\t\tstringEdit: new StringEdit([this._trimmedEdit]),\n\t\t\talternativeAction: undefined,\n\t\t\ttarget: this.originalTextRef,\n\t\t};\n\t}\n\n\toverride get hash(): string {\n\t\treturn JSON.stringify(this._trimmedEdit.toJson());\n\t}\n\n\tgetSingleTextEdit(): TextReplacement { return this._textEdit; }\n\n\toverride withIdentity(identity: InlineSuggestionIdentity): InlineCompletionItem {\n\t\treturn new InlineCompletionItem(\n\t\t\tthis._edit,\n\t\t\tthis._trimmedEdit,\n\t\t\tthis._textEdit,\n\t\t\tthis._originalRange,\n\t\t\tthis.snippetInfo,\n\t\t\tthis.additionalTextEdits,\n\t\t\tthis._data,\n\t\t\tidentity,\n\t\t\tthis.hint,\n\t\t\tthis.originalTextRef\n\t\t);\n\t}\n\n\toverride withEdit(textModelEdit: StringEdit, textModel: ITextModel): InlineCompletionItem | undefined {\n\t\t// If the edit is to a different model than our target, it's a noop\n\t\tif (!this.originalTextRef.targets(textModel)) {\n\t\t\treturn this;  // unchanged\n\t\t}\n\n\t\tconst newEditRange = applyEditsToRanges([this._edit.replaceRange], textModelEdit);\n\t\tif (newEditRange.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst newEdit = new StringReplacement(newEditRange[0], this._textEdit.text);\n\t\tconst positionOffsetTransformer = getPositionOffsetTransformerFromTextModel(textModel);\n\t\tconst newTextEdit = positionOffsetTransformer.getTextReplacement(newEdit);\n\n\t\tlet newDisplayLocation = this.hint;\n\t\tif (newDisplayLocation) {\n\t\t\tnewDisplayLocation = newDisplayLocation.withEdit(textModelEdit, positionOffsetTransformer);\n\t\t\tif (!newDisplayLocation) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\tconst trimmedEdit = newEdit.removeCommonSuffixAndPrefix(textModel.getValue());\n\n\t\treturn new InlineCompletionItem(\n\t\t\tnewEdit,\n\t\t\ttrimmedEdit,\n\t\t\tnewTextEdit,\n\t\t\tthis._originalRange,\n\t\t\tthis.snippetInfo,\n\t\t\tthis.additionalTextEdits,\n\t\t\tthis._data,\n\t\t\tthis.identity,\n\t\t\tnewDisplayLocation,\n\t\t\tthis.originalTextRef\n\t\t);\n\t}\n\n\toverride canBeReused(model: ITextModel, position: Position): boolean {\n\t\t// TODO@hediet I believe this can be simplified to `return true;`, as applying an edit should kick out this suggestion.\n\t\tconst updatedRange = this._textEdit.range;\n\t\tconst result = !!updatedRange\n\t\t\t&& updatedRange.containsPosition(position)\n\t\t\t&& this.isVisible(model, position)\n\t\t\t&& TextLength.ofRange(updatedRange).isGreaterThanOrEqualTo(TextLength.ofRange(this._originalRange));\n\t\treturn result;\n\t}\n\n\tpublic isVisible(model: ITextModel, cursorPosition: Position): boolean {\n\t\tconst singleTextEdit = this.getSingleTextEdit();\n\t\treturn inlineCompletionIsVisible(singleTextEdit, this._originalRange, model, cursorPosition);\n\t}\n\n\toverride computeEditKind(model: ITextModel): InlineSuggestionEditKind | undefined {\n\t\treturn computeEditKind(new StringEdit([this._edit]), model);\n\t}\n\n\tpublic get editRange(): Range { return this.getSingleTextEdit().range; }\n}\n\nexport class InlineEditItem extends InlineSuggestionItemBase {\n\n\tpublic static create(\n\t\tdata: InlineSuggestData,\n\t\ttextModel: TextModelValueReference,\n\t\tshouldDiffEdit: boolean = true,\n\t): InlineEditItem {\n\t\tlet action: InlineSuggestionAction | undefined;\n\t\tlet edits: SingleUpdatedNextEdit[] = [];\n\t\tif (data.action?.kind === 'edit') {\n\t\t\tconst offsetEdit = shouldDiffEdit ? getDiffedStringEdit(textModel, data.action.range, data.action.insertText) : getStringEdit(textModel, data.action.range, data.action.insertText); // TODO compute async\n\t\t\tconst textEdit = TextEdit.fromStringEdit(offsetEdit, textModel);\n\t\t\tconst singleTextEdit = offsetEdit.isEmpty() ? new TextReplacement(new Range(1, 1, 1, 1), '') : textEdit.toReplacement(textModel); // FIXME: .toReplacement() can throw because offsetEdit is empty because we get an empty diff in getStringEdit after diffing\n\n\t\t\tedits = offsetEdit.replacements.map(edit => {\n\t\t\t\tconst replacedRange = Range.fromPositions(textModel.getPositionAt(edit.replaceRange.start), textModel.getTransformer().getPosition(edit.replaceRange.endExclusive));\n\t\t\t\tconst replacedText = textModel.getValueInRange(replacedRange);\n\t\t\t\treturn SingleUpdatedNextEdit.create(edit, replacedText);\n\t\t\t});\n\n\t\t\taction = {\n\t\t\t\tkind: 'edit',\n\t\t\t\tsnippetInfo: data.action.snippetInfo,\n\t\t\t\tstringEdit: offsetEdit,\n\t\t\t\ttextReplacement: singleTextEdit,\n\t\t\t\talternativeAction: data.action.alternativeAction,\n\t\t\t\ttarget: textModel,\n\t\t\t};\n\t\t} else if (data.action?.kind === 'jumpTo') {\n\t\t\taction = {\n\t\t\t\tkind: 'jumpTo',\n\t\t\t\tposition: data.action.position,\n\t\t\t\toffset: textModel.getTransformer().getOffset(data.action.position),\n\t\t\t\ttarget: textModel,\n\t\t\t};\n\t\t} else {\n\t\t\taction = undefined;\n\t\t\tif (!data.hint) {\n\t\t\t\tthrow new BugIndicatingError('InlineEditItem: action is undefined and no hint is provided');\n\t\t\t}\n\t\t}\n\n\t\tconst identity = new InlineSuggestionIdentity();\n\n\t\tconst hint = data.hint ? InlineSuggestHint.create(data.hint) : undefined;\n\t\treturn new InlineEditItem(action, data, identity, edits, hint, false, textModel.getVersionId(), textModel);\n\t}\n\n\tpublic readonly snippetInfo: SnippetInfo | undefined = undefined;\n\tpublic readonly additionalTextEdits: readonly ISingleEditOperation[] = [];\n\tpublic readonly isInlineEdit = true;\n\n\tprivate constructor(\n\t\tprivate readonly _action: InlineSuggestionAction | undefined,\n\n\t\tdata: InlineSuggestData,\n\n\t\tidentity: InlineSuggestionIdentity,\n\t\tprivate readonly _edits: readonly SingleUpdatedNextEdit[],\n\t\thint: InlineSuggestHint | undefined,\n\t\tprivate readonly _lastChangePartOfInlineEdit = false,\n\t\tprivate readonly _inlineEditModelVersion: number,\n\t\toriginalTextRef: TextModelValueReference,\n\t) {\n\t\tsuper(data, identity, hint, originalTextRef);\n\t}\n\n\tpublic get updatedEditModelVersion(): number { return this._inlineEditModelVersion; }\n\t// public get updatedEdit(): StringEdit { return this._edit; }\n\n\toverride get action(): InlineSuggestionAction | undefined {\n\t\treturn this._action;\n\t}\n\n\toverride withIdentity(identity: InlineSuggestionIdentity): InlineEditItem {\n\t\treturn new InlineEditItem(\n\t\t\tthis._action,\n\t\t\tthis._data,\n\t\t\tidentity,\n\t\t\tthis._edits,\n\t\t\tthis.hint,\n\t\t\tthis._lastChangePartOfInlineEdit,\n\t\t\tthis._inlineEditModelVersion,\n\t\t\tthis.originalTextRef,\n\t\t);\n\t}\n\n\toverride canBeReused(model: ITextModel, position: Position): boolean {\n\t\t// TODO@hediet I believe this can be simplified to `return true;`, as applying an edit should kick out this suggestion.\n\t\treturn this._lastChangePartOfInlineEdit && this.updatedEditModelVersion === model.getVersionId();\n\t}\n\n\toverride withEdit(textModelChanges: StringEdit, textModel: ITextModel): InlineEditItem | undefined {\n\t\t// If the edit is to a different model than our target, it's a noop\n\t\tif (!this.originalTextRef.targets(textModel)) {\n\t\t\treturn this;  // unchanged\n\t\t}\n\n\t\tconst edit = this._applyTextModelChanges(textModelChanges, this._edits, textModel);\n\t\treturn edit;\n\t}\n\n\tprivate _applyTextModelChanges(textModelChanges: StringEdit, edits: readonly SingleUpdatedNextEdit[], textModel: ITextModel): InlineEditItem | undefined {\n\t\tconst positionOffsetTransformer = getPositionOffsetTransformerFromTextModel(textModel);\n\n\t\tlet lastChangePartOfInlineEdit = false;\n\t\tlet inlineEditModelVersion = this._inlineEditModelVersion;\n\t\tlet newAction: InlineSuggestionAction | undefined;\n\n\t\tif (this.action?.kind === 'edit') { // TODO What about rename?\n\t\t\tedits = edits.map(innerEdit => innerEdit.applyTextModelChanges(textModelChanges));\n\n\t\t\tif (edits.some(edit => edit.edit === undefined)) {\n\t\t\t\treturn undefined; // change is invalid, so we will have to drop the completion\n\t\t\t}\n\n\n\t\t\tconst newTextModelVersion = textModel.getVersionId();\n\t\t\tlastChangePartOfInlineEdit = edits.some(edit => edit.lastChangeUpdatedEdit);\n\t\t\tif (lastChangePartOfInlineEdit) {\n\t\t\t\tinlineEditModelVersion = newTextModelVersion ?? -1;\n\t\t\t}\n\n\t\t\tif (newTextModelVersion === null || inlineEditModelVersion + 20 < newTextModelVersion) {\n\t\t\t\treturn undefined; // the completion has been ignored for a while, remove it\n\t\t\t}\n\n\t\t\tedits = edits.filter(innerEdit => !innerEdit.edit!.isEmpty);\n\t\t\tif (edits.length === 0) {\n\t\t\t\treturn undefined; // the completion has been typed by the user\n\t\t\t}\n\n\t\t\tconst newEdit = new StringEdit(edits.map(edit => edit.edit!));\n\n\t\t\tconst newTextEdit = positionOffsetTransformer.getTextEdit(newEdit).toReplacement(new TextModelText(textModel));\n\n\t\t\tnewAction = {\n\t\t\t\tkind: 'edit',\n\t\t\t\ttextReplacement: newTextEdit,\n\t\t\t\tsnippetInfo: this.snippetInfo,\n\t\t\t\tstringEdit: newEdit,\n\t\t\t\talternativeAction: this.action.alternativeAction,\n\t\t\t\ttarget: this.originalTextRef,\n\t\t\t};\n\t\t} else if (this.action?.kind === 'jumpTo') {\n\t\t\tconst jumpToOffset = this.action.offset;\n\t\t\tconst newJumpToOffset = textModelChanges.applyToOffsetOrUndefined(jumpToOffset);\n\t\t\tif (newJumpToOffset === undefined) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tconst newJumpToPosition = positionOffsetTransformer.getPosition(newJumpToOffset);\n\n\t\t\tnewAction = {\n\t\t\t\tkind: 'jumpTo',\n\t\t\t\tposition: newJumpToPosition,\n\t\t\t\toffset: newJumpToOffset,\n\t\t\t\ttarget: this.originalTextRef,\n\t\t\t};\n\t\t} else {\n\t\t\tnewAction = undefined;\n\t\t}\n\n\t\tlet newDisplayLocation = this.hint;\n\t\tif (newDisplayLocation) {\n\t\t\tnewDisplayLocation = newDisplayLocation.withEdit(textModelChanges, positionOffsetTransformer);\n\t\t\tif (!newDisplayLocation) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\treturn new InlineEditItem(\n\t\t\tnewAction,\n\t\t\tthis._data,\n\t\t\tthis.identity,\n\t\t\tedits,\n\t\t\tnewDisplayLocation,\n\t\t\tlastChangePartOfInlineEdit,\n\t\t\tinlineEditModelVersion,\n\t\t\tthis.originalTextRef,\n\t\t);\n\t}\n\n\toverride computeEditKind(model: ITextModel): InlineSuggestionEditKind | undefined {\n\t\tconst edit = this.action?.kind === 'edit' ? this.action.stringEdit : undefined;\n\t\tif (!edit) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn computeEditKind(edit, model);\n\t}\n}\n\nfunction getDiffedStringEdit(textModel: TextModelValueReference, editRange: Range, replaceText: string): StringEdit {\n\tconst eol = textModel.getEOL();\n\tconst editOriginalText = textModel.getValueOfRange(editRange);\n\tconst editReplaceText = replaceText.replace(/\\r\\n|\\r|\\n/g, eol);\n\n\tconst diffAlgorithm = linesDiffComputers.getDefault();\n\tconst lineDiffs = diffAlgorithm.computeDiff(\n\t\tsplitLines(editOriginalText),\n\t\tsplitLines(editReplaceText),\n\t\t{\n\t\t\tignoreTrimWhitespace: false,\n\t\t\tcomputeMoves: false,\n\t\t\textendToSubwords: true,\n\t\t\tmaxComputationTimeMs: 50,\n\t\t}\n\t);\n\n\tconst innerChanges = lineDiffs.changes.flatMap(c => c.innerChanges ?? []);\n\n\tfunction addRangeToPos(pos: Position, range: Range): Range {\n\t\tconst start = TextLength.fromPosition(range.getStartPosition());\n\t\treturn TextLength.ofRange(range).createRange(start.addToPosition(pos));\n\t}\n\n\tconst modifiedText = new StringText(editReplaceText);\n\n\tconst offsetEdit = new StringEdit(\n\t\tinnerChanges.map(c => {\n\t\t\tconst rangeInModel = addRangeToPos(editRange.getStartPosition(), c.originalRange);\n\t\t\tconst originalRange = textModel.getTransformer().getOffsetRange(rangeInModel);\n\n\t\t\tconst replaceText = modifiedText.getValueOfRange(c.modifiedRange);\n\t\t\tconst edit = new StringReplacement(originalRange, replaceText);\n\n\t\t\tconst originalText = textModel.getValueOfRange(rangeInModel);\n\t\t\treturn reshapeInlineEdit(edit, originalText, innerChanges.length, textModel);\n\t\t})\n\t);\n\n\treturn offsetEdit;\n}\n\nfunction getStringEdit(textModel: TextModelValueReference, editRange: Range, replaceText: string): StringEdit {\n\treturn new StringEdit([new StringReplacement(\n\t\ttextModel.getTransformer().getOffsetRange(editRange),\n\t\treplaceText\n\t)]);\n}\n\nclass SingleUpdatedNextEdit {\n\tpublic static create(\n\t\tedit: StringReplacement,\n\t\treplacedText: string,\n\t): SingleUpdatedNextEdit {\n\t\tconst prefixLength = commonPrefixLength(edit.newText, replacedText);\n\t\tconst suffixLength = commonSuffixLength(edit.newText, replacedText);\n\t\tconst trimmedNewText = edit.newText.substring(prefixLength, edit.newText.length - suffixLength);\n\t\treturn new SingleUpdatedNextEdit(edit, trimmedNewText, prefixLength, suffixLength);\n\t}\n\n\tpublic get edit() { return this._edit; }\n\tpublic get lastChangeUpdatedEdit() { return this._lastChangeUpdatedEdit; }\n\n\tconstructor(\n\t\tprivate _edit: StringReplacement | undefined,\n\t\tprivate _trimmedNewText: string,\n\t\tprivate _prefixLength: number,\n\t\tprivate _suffixLength: number,\n\t\tprivate _lastChangeUpdatedEdit: boolean = false,\n\t) {\n\t}\n\n\tpublic applyTextModelChanges(textModelChanges: StringEdit) {\n\t\tconst c = this._clone();\n\t\tc._applyTextModelChanges(textModelChanges);\n\t\treturn c;\n\t}\n\n\tprivate _clone(): SingleUpdatedNextEdit {\n\t\treturn new SingleUpdatedNextEdit(\n\t\t\tthis._edit,\n\t\t\tthis._trimmedNewText,\n\t\t\tthis._prefixLength,\n\t\t\tthis._suffixLength,\n\t\t\tthis._lastChangeUpdatedEdit,\n\t\t);\n\t}\n\n\tprivate _applyTextModelChanges(textModelChanges: StringEdit) {\n\t\tthis._lastChangeUpdatedEdit = false; // TODO @benibenj make immutable\n\n\t\tif (!this._edit) {\n\t\t\tthrow new BugIndicatingError('UpdatedInnerEdits: No edit to apply changes to');\n\t\t}\n\n\t\tconst result = this._applyChanges(this._edit, textModelChanges);\n\t\tif (!result) {\n\t\t\tthis._edit = undefined;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._edit = result.edit;\n\t\tthis._lastChangeUpdatedEdit = result.editHasChanged;\n\t}\n\n\tprivate _applyChanges(edit: StringReplacement, textModelChanges: StringEdit): { edit: StringReplacement; editHasChanged: boolean } | undefined {\n\t\tlet editStart = edit.replaceRange.start;\n\t\tlet editEnd = edit.replaceRange.endExclusive;\n\t\tlet editReplaceText = edit.newText;\n\t\tlet editHasChanged = false;\n\n\t\tconst shouldPreserveEditShape = this._prefixLength > 0 || this._suffixLength > 0;\n\n\t\tfor (let i = textModelChanges.replacements.length - 1; i >= 0; i--) {\n\t\t\tconst change = textModelChanges.replacements[i];\n\n\t\t\t// INSERTIONS (only support inserting at start of edit)\n\t\t\tconst isInsertion = change.newText.length > 0 && change.replaceRange.isEmpty;\n\n\t\t\tif (isInsertion && !shouldPreserveEditShape && change.replaceRange.start === editStart && editReplaceText.startsWith(change.newText)) {\n\t\t\t\teditStart += change.newText.length;\n\t\t\t\teditReplaceText = editReplaceText.substring(change.newText.length);\n\t\t\t\teditEnd += change.newText.length;\n\t\t\t\teditHasChanged = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (isInsertion && shouldPreserveEditShape && change.replaceRange.start === editStart + this._prefixLength && this._trimmedNewText.startsWith(change.newText)) {\n\t\t\t\teditEnd += change.newText.length;\n\t\t\t\teditHasChanged = true;\n\t\t\t\tthis._prefixLength += change.newText.length;\n\t\t\t\tthis._trimmedNewText = this._trimmedNewText.substring(change.newText.length);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// DELETIONS\n\t\t\tconst isDeletion = change.newText.length === 0 && change.replaceRange.length > 0;\n\t\t\tif (isDeletion && change.replaceRange.start >= editStart + this._prefixLength && change.replaceRange.endExclusive <= editEnd - this._suffixLength) {\n\t\t\t\t// user deleted text IN-BETWEEN the deletion range\n\t\t\t\teditEnd -= change.replaceRange.length;\n\t\t\t\teditHasChanged = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// user did exactly the edit\n\t\t\tif (change.equals(edit)) {\n\t\t\t\teditHasChanged = true;\n\t\t\t\teditStart = change.replaceRange.endExclusive;\n\t\t\t\teditReplaceText = '';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// MOVE EDIT\n\t\t\tif (change.replaceRange.start > editEnd) {\n\t\t\t\t// the change happens after the completion range\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (change.replaceRange.endExclusive < editStart) {\n\t\t\t\t// the change happens before the completion range\n\t\t\t\teditStart += change.newText.length - change.replaceRange.length;\n\t\t\t\teditEnd += change.newText.length - change.replaceRange.length;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// The change intersects the completion, so we will have to drop the completion\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// the resulting edit is a noop as the original and new text are the same\n\t\tif (this._trimmedNewText.length === 0 && editStart + this._prefixLength === editEnd - this._suffixLength) {\n\t\t\treturn { edit: new StringReplacement(new OffsetRange(editStart + this._prefixLength, editStart + this._prefixLength), ''), editHasChanged: true };\n\t\t}\n\n\t\treturn { edit: new StringReplacement(new OffsetRange(editStart, editEnd), editReplaceText), editHasChanged };\n\t}\n}\n\nfunction reshapeInlineCompletion(edit: StringReplacement, textModel: TextModelValueReference): StringReplacement {\n\t// If the insertion is a multi line insertion starting on the next line\n\t// Move it forwards so that the multi line insertion starts on the current line\n\tconst eol = textModel.getEOL();\n\tif (edit.replaceRange.isEmpty && edit.newText.includes(eol)) {\n\t\tedit = reshapeMultiLineInsertion(edit, textModel);\n\t}\n\n\treturn edit;\n}\n\nfunction reshapeInlineEdit(edit: StringReplacement, originalText: string, totalInnerEdits: number, textModel: TextModelValueReference): StringReplacement {\n\t// TODO: EOL are not properly trimmed by the diffAlgorithm #12680\n\tconst eol = textModel.getEOL();\n\tif (edit.newText.endsWith(eol) && originalText.endsWith(eol)) {\n\t\tedit = new StringReplacement(edit.replaceRange.deltaEnd(-eol.length), edit.newText.slice(0, -eol.length));\n\t}\n\n\t// INSERTION\n\t// If the insertion ends with a new line and is inserted at the start of a line which has text,\n\t// we move the insertion to the end of the previous line if possible\n\tif (totalInnerEdits === 1 && edit.replaceRange.isEmpty && edit.newText.includes(eol)) {\n\t\tconst startPosition = textModel.getTransformer().getPosition(edit.replaceRange.start);\n\t\tconst hasTextOnInsertionLine = textModel.getLineLength(startPosition.lineNumber) !== 0;\n\t\tif (hasTextOnInsertionLine) {\n\t\t\tedit = reshapeMultiLineInsertion(edit, textModel);\n\t\t}\n\t}\n\n\t// The diff algorithm extended a simple edit to the entire word\n\t// shrink it back to a simple edit if it is deletion/insertion only\n\tif (totalInnerEdits === 1) {\n\t\tconst prefixLength = commonPrefixLength(originalText, edit.newText);\n\t\tconst suffixLength = commonSuffixLength(originalText.slice(prefixLength), edit.newText.slice(prefixLength));\n\n\t\t// reshape it back to an insertion\n\t\tif (prefixLength + suffixLength === originalText.length) {\n\t\t\treturn new StringReplacement(edit.replaceRange.deltaStart(prefixLength).deltaEnd(-suffixLength), edit.newText.substring(prefixLength, edit.newText.length - suffixLength));\n\t\t}\n\n\t\t// reshape it back to a deletion\n\t\tif (prefixLength + suffixLength === edit.newText.length) {\n\t\t\treturn new StringReplacement(edit.replaceRange.deltaStart(prefixLength).deltaEnd(-suffixLength), '');\n\t\t}\n\t}\n\n\treturn edit;\n}\n\nfunction reshapeMultiLineInsertion(edit: StringReplacement, textModel: TextModelValueReference): StringReplacement {\n\tif (!edit.replaceRange.isEmpty) {\n\t\tthrow new BugIndicatingError('Unexpected original range');\n\t}\n\n\tif (edit.replaceRange.start === 0) {\n\t\treturn edit;\n\t}\n\n\tconst eol = textModel.getEOL();\n\tconst startPosition = textModel.getTransformer().getPosition(edit.replaceRange.start);\n\tconst startColumn = startPosition.column;\n\tconst startLineNumber = startPosition.lineNumber;\n\n\t// If the insertion ends with a new line and is inserted at the start of a line which has text,\n\t// we move the insertion to the end of the previous line if possible\n\tif (startColumn === 1 && startLineNumber > 1 && edit.newText.endsWith(eol) && !edit.newText.startsWith(eol)) {\n\t\treturn new StringReplacement(edit.replaceRange.delta(-1), eol + edit.newText.slice(0, -eol.length));\n\t}\n\n\treturn edit;\n}\n"]}