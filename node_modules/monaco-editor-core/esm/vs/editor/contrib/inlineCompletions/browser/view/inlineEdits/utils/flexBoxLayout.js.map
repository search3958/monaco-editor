{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/utils/flexBoxLayout.ts","vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/utils/flexBoxLayout.ts"],"names":[],"mappings":"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","file":"flexBoxLayout.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface IFlexBoxPartGrowthRule extends IFlexBoxPartExtensionRule {\n\tmin?: number;\n\trules?: IFlexBoxPartExtensionRule[];\n}\n\nexport interface IFlexBoxPartExtensionRule {\n\tmax?: number;\n\tpriority?: number;\n\tshare?: number;\n}\n\n\n/**\n * Distributes a total size into parts that each have a list of growth rules.\n * Returns `null` if the layout is not possible.\n * The sum of all returned sizes will be equal to `totalSize`.\n *\n * First, each part gets its minimum size.\n * Then, remaining space is distributed to the rules with the highest priority, as long as the max constraint allows it (considering share).\n * This continues with next lower priority rules until no space is left.\n*/\nexport function distributeFlexBoxLayout<T extends Record<string, IFlexBoxPartGrowthRule | IFlexBoxPartGrowthRule[]>>(\n\ttotalSize: number,\n\tparts: T & Record<string, IFlexBoxPartGrowthRule | IFlexBoxPartGrowthRule[]>\n): Record<keyof T, number> | null {\n\t// Normalize parts to always have array of rules\n\tconst normalizedParts: Record<string, { min: number; rules: IFlexBoxPartExtensionRule[] }> = {};\n\tfor (const [key, part] of Object.entries(parts)) {\n\t\tif (Array.isArray(part)) {\n\t\t\tnormalizedParts[key] = { min: 0, rules: part };\n\t\t} else {\n\t\t\tnormalizedParts[key] = {\n\t\t\t\tmin: part.min ?? 0,\n\t\t\t\trules: part.rules ?? [{ max: part.max, priority: part.priority, share: part.share }]\n\t\t\t};\n\t\t}\n\t}\n\n\t// Initialize result with minimum sizes\n\tconst result: Record<string, number> = {};\n\tlet usedSize = 0;\n\tfor (const [key, part] of Object.entries(normalizedParts)) {\n\t\tresult[key] = part.min;\n\t\tusedSize += part.min;\n\t}\n\n\t// Check if we can satisfy minimum constraints\n\tif (usedSize > totalSize) {\n\t\treturn null;\n\t}\n\n\tlet remainingSize = totalSize - usedSize;\n\n\t// Distribute remaining space by priority levels\n\twhile (remainingSize > 0) {\n\t\t// Find all rules at current highest priority that can still grow\n\t\tconst candidateRules: Array<{\n\t\t\tpartKey: string;\n\t\t\truleIndex: number;\n\t\t\trule: IFlexBoxPartExtensionRule;\n\t\t\tpriority: number;\n\t\t\tshare: number;\n\t\t}> = [];\n\n\t\tfor (const [key, part] of Object.entries(normalizedParts)) {\n\t\t\tfor (let i = 0; i < part.rules.length; i++) {\n\t\t\t\tconst rule = part.rules[i];\n\t\t\t\tconst currentUsage = result[key];\n\t\t\t\tconst maxSize = rule.max ?? Infinity;\n\n\t\t\t\tif (currentUsage < maxSize) {\n\t\t\t\t\tcandidateRules.push({\n\t\t\t\t\t\tpartKey: key,\n\t\t\t\t\t\truleIndex: i,\n\t\t\t\t\t\trule,\n\t\t\t\t\t\tpriority: rule.priority ?? 0,\n\t\t\t\t\t\tshare: rule.share ?? 1\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (candidateRules.length === 0) {\n\t\t\t// No rules can grow anymore, but we have remaining space\n\t\t\tbreak;\n\t\t}\n\n\t\t// Find the highest priority among candidates\n\t\tconst maxPriority = Math.max(...candidateRules.map(c => c.priority));\n\t\tconst highestPriorityCandidates = candidateRules.filter(c => c.priority === maxPriority);\n\n\t\t// Calculate total share\n\t\tconst totalShare = highestPriorityCandidates.reduce((sum, c) => sum + c.share, 0);\n\n\t\t// Distribute space proportionally by share\n\t\tlet distributedThisRound = 0;\n\t\tconst distributions: Array<{ partKey: string; ruleIndex: number; amount: number }> = [];\n\n\t\tfor (const candidate of highestPriorityCandidates) {\n\t\t\tconst rule = candidate.rule;\n\t\t\tconst currentUsage = result[candidate.partKey];\n\t\t\tconst maxSize = rule.max ?? Infinity;\n\t\t\tconst availableForThisRule = maxSize - currentUsage;\n\n\t\t\t// Calculate ideal share\n\t\t\tconst idealShare = (remainingSize * candidate.share) / totalShare;\n\t\t\tconst actualAmount = Math.min(idealShare, availableForThisRule);\n\n\t\t\tdistributions.push({\n\t\t\t\tpartKey: candidate.partKey,\n\t\t\t\truleIndex: candidate.ruleIndex,\n\t\t\t\tamount: actualAmount\n\t\t\t});\n\n\t\t\tdistributedThisRound += actualAmount;\n\t\t}\n\n\t\tif (distributedThisRound === 0) {\n\t\t\t// No progress can be made\n\t\t\tbreak;\n\t\t}\n\n\t\t// Apply distributions\n\t\tfor (const dist of distributions) {\n\t\t\tresult[dist.partKey] += dist.amount;\n\t\t}\n\n\t\tremainingSize -= distributedThisRound;\n\n\t\t// Break if remaining is negligible (floating point precision)\n\t\tif (remainingSize < 0.0001) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result as Record<keyof T, number>;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface IFlexBoxPartGrowthRule extends IFlexBoxPartExtensionRule {\n\tmin?: number;\n\trules?: IFlexBoxPartExtensionRule[];\n}\n\nexport interface IFlexBoxPartExtensionRule {\n\tmax?: number;\n\tpriority?: number;\n\tshare?: number;\n}\n\n\n/**\n * Distributes a total size into parts that each have a list of growth rules.\n * Returns `null` if the layout is not possible.\n * The sum of all returned sizes will be equal to `totalSize`.\n *\n * First, each part gets its minimum size.\n * Then, remaining space is distributed to the rules with the highest priority, as long as the max constraint allows it (considering share).\n * This continues with next lower priority rules until no space is left.\n*/\nexport function distributeFlexBoxLayout<T extends Record<string, IFlexBoxPartGrowthRule | IFlexBoxPartGrowthRule[]>>(\n\ttotalSize: number,\n\tparts: T & Record<string, IFlexBoxPartGrowthRule | IFlexBoxPartGrowthRule[]>\n): Record<keyof T, number> | null {\n\t// Normalize parts to always have array of rules\n\tconst normalizedParts: Record<string, { min: number; rules: IFlexBoxPartExtensionRule[] }> = {};\n\tfor (const [key, part] of Object.entries(parts)) {\n\t\tif (Array.isArray(part)) {\n\t\t\tnormalizedParts[key] = { min: 0, rules: part };\n\t\t} else {\n\t\t\tnormalizedParts[key] = {\n\t\t\t\tmin: part.min ?? 0,\n\t\t\t\trules: part.rules ?? [{ max: part.max, priority: part.priority, share: part.share }]\n\t\t\t};\n\t\t}\n\t}\n\n\t// Initialize result with minimum sizes\n\tconst result: Record<string, number> = {};\n\tlet usedSize = 0;\n\tfor (const [key, part] of Object.entries(normalizedParts)) {\n\t\tresult[key] = part.min;\n\t\tusedSize += part.min;\n\t}\n\n\t// Check if we can satisfy minimum constraints\n\tif (usedSize > totalSize) {\n\t\treturn null;\n\t}\n\n\tlet remainingSize = totalSize - usedSize;\n\n\t// Distribute remaining space by priority levels\n\twhile (remainingSize > 0) {\n\t\t// Find all rules at current highest priority that can still grow\n\t\tconst candidateRules: Array<{\n\t\t\tpartKey: string;\n\t\t\truleIndex: number;\n\t\t\trule: IFlexBoxPartExtensionRule;\n\t\t\tpriority: number;\n\t\t\tshare: number;\n\t\t}> = [];\n\n\t\tfor (const [key, part] of Object.entries(normalizedParts)) {\n\t\t\tfor (let i = 0; i < part.rules.length; i++) {\n\t\t\t\tconst rule = part.rules[i];\n\t\t\t\tconst currentUsage = result[key];\n\t\t\t\tconst maxSize = rule.max ?? Infinity;\n\n\t\t\t\tif (currentUsage < maxSize) {\n\t\t\t\t\tcandidateRules.push({\n\t\t\t\t\t\tpartKey: key,\n\t\t\t\t\t\truleIndex: i,\n\t\t\t\t\t\trule,\n\t\t\t\t\t\tpriority: rule.priority ?? 0,\n\t\t\t\t\t\tshare: rule.share ?? 1\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (candidateRules.length === 0) {\n\t\t\t// No rules can grow anymore, but we have remaining space\n\t\t\tbreak;\n\t\t}\n\n\t\t// Find the highest priority among candidates\n\t\tconst maxPriority = Math.max(...candidateRules.map(c => c.priority));\n\t\tconst highestPriorityCandidates = candidateRules.filter(c => c.priority === maxPriority);\n\n\t\t// Calculate total share\n\t\tconst totalShare = highestPriorityCandidates.reduce((sum, c) => sum + c.share, 0);\n\n\t\t// Distribute space proportionally by share\n\t\tlet distributedThisRound = 0;\n\t\tconst distributions: Array<{ partKey: string; ruleIndex: number; amount: number }> = [];\n\n\t\tfor (const candidate of highestPriorityCandidates) {\n\t\t\tconst rule = candidate.rule;\n\t\t\tconst currentUsage = result[candidate.partKey];\n\t\t\tconst maxSize = rule.max ?? Infinity;\n\t\t\tconst availableForThisRule = maxSize - currentUsage;\n\n\t\t\t// Calculate ideal share\n\t\t\tconst idealShare = (remainingSize * candidate.share) / totalShare;\n\t\t\tconst actualAmount = Math.min(idealShare, availableForThisRule);\n\n\t\t\tdistributions.push({\n\t\t\t\tpartKey: candidate.partKey,\n\t\t\t\truleIndex: candidate.ruleIndex,\n\t\t\t\tamount: actualAmount\n\t\t\t});\n\n\t\t\tdistributedThisRound += actualAmount;\n\t\t}\n\n\t\tif (distributedThisRound === 0) {\n\t\t\t// No progress can be made\n\t\t\tbreak;\n\t\t}\n\n\t\t// Apply distributions\n\t\tfor (const dist of distributions) {\n\t\t\tresult[dist.partKey] += dist.amount;\n\t\t}\n\n\t\tremainingSize -= distributedThisRound;\n\n\t\t// Break if remaining is negligible (floating point precision)\n\t\tif (remainingSize < 0.0001) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result as Record<keyof T, number>;\n}\n"]}