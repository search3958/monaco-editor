{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/inlineEditsViews/longDistanceHint/longDistnaceWidgetPlacement.ts","vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/inlineEditsViews/longDistanceHint/longDistnaceWidgetPlacement.ts"],"names":[],"mappings":"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","file":"longDistnaceWidgetPlacement.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { derived, IReader } from '../../../../../../../../base/common/observable.js';\nimport { ObservableCodeEditor } from '../../../../../../../browser/observableCodeEditor.js';\nimport { Size2D } from '../../../../../../../common/core/2d/size.js';\nimport { LineRange } from '../../../../../../../common/core/ranges/lineRange.js';\nimport { OffsetRange } from '../../../../../../../common/core/ranges/offsetRange.js';\nimport { getMaxTowerHeightInAvailableArea } from '../../utils/towersLayout.js';\n\n/**\n * Layout constants used for the long-distance hint widget.\n */\nexport interface WidgetLayoutConstants {\n\treadonly previewEditorMargin: number;\n\treadonly widgetPadding: number;\n\treadonly widgetBorder: number;\n\treadonly lowerBarHeight: number;\n\treadonly minWidgetWidth: number;\n}\n/**\n * Represents a widget placement outline with horizontal and vertical ranges.\n */\nexport interface WidgetOutline {\n\treadonly horizontalWidgetRange: OffsetRange;\n\treadonly verticalWidgetRange: OffsetRange;\n}\n/**\n * Represents a continuous range of lines with their sizes and positioning.\n * Used to compute available space for widget placement.\n */\nexport interface ContinuousLineSizes {\n\treadonly lineRange: LineRange;\n\treadonly top: number;\n\treadonly sizes: Size2D[];\n}\n/**\n * Context for computing widget placement within a continuous line range.\n */\nexport class WidgetPlacementContext {\n\tpublic readonly availableSpaceSizes: Size2D[];\n\tpublic readonly availableSpaceHeightPrefixSums: number[];\n\tpublic readonly availableSpaceSizesTransposed: Size2D[];\n\n\tconstructor(\n\t\tprivate readonly _lineRangeInfo: ContinuousLineSizes,\n\t\teditorTrueContentWidth: number,\n\t\tendOfLinePadding: (lineNumber: number) => number,\n\t) {\n\t\tthis.availableSpaceSizes = _lineRangeInfo.sizes.map((s, idx) => {\n\t\t\tconst lineNumber = _lineRangeInfo.lineRange.startLineNumber + idx;\n\t\t\tconst linePaddingLeft = endOfLinePadding(lineNumber);\n\t\t\treturn new Size2D(Math.max(0, editorTrueContentWidth - s.width - linePaddingLeft), s.height);\n\t\t});\n\n\t\tthis.availableSpaceHeightPrefixSums = getSums(this.availableSpaceSizes, s => s.height);\n\t\tthis.availableSpaceSizesTransposed = this.availableSpaceSizes.map(s => s.transpose());\n\t}\n\n\t/**\n\t * Computes the vertical outline for a widget placed at the given line number.\n\t */\n\tpublic getWidgetVerticalOutline(\n\t\tlineNumber: number,\n\t\tpreviewEditorHeight: number,\n\t\tlayoutConstants: WidgetLayoutConstants\n\t): OffsetRange {\n\t\tconst sizeIdx = lineNumber - this._lineRangeInfo.lineRange.startLineNumber;\n\t\tconst top = this._lineRangeInfo.top + this.availableSpaceHeightPrefixSums[sizeIdx];\n\t\tconst editorRange = OffsetRange.ofStartAndLength(top, previewEditorHeight);\n\t\tconst { previewEditorMargin, widgetPadding, widgetBorder, lowerBarHeight } = layoutConstants;\n\t\tconst verticalWidgetRange = editorRange.withMargin(previewEditorMargin + widgetPadding + widgetBorder).withMargin(0, lowerBarHeight);\n\t\treturn verticalWidgetRange;\n\t}\n\n\t/**\n\t * Tries to find a valid widget outline within this line range context.\n\t */\n\tpublic tryFindWidgetOutline(\n\t\ttargetLineNumber: number,\n\t\tpreviewEditorHeight: number,\n\t\teditorTrueContentRight: number,\n\t\tlayoutConstants: WidgetLayoutConstants\n\t): WidgetOutline | undefined {\n\t\tif (this._lineRangeInfo.lineRange.length < 3) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn findFirstMinimzeDistance(\n\t\t\tthis._lineRangeInfo.lineRange.addMargin(-1, -1),\n\t\t\ttargetLineNumber,\n\t\t\tlineNumber => {\n\t\t\t\tconst verticalWidgetRange = this.getWidgetVerticalOutline(lineNumber, previewEditorHeight, layoutConstants);\n\t\t\t\tconst maxWidth = getMaxTowerHeightInAvailableArea(\n\t\t\t\t\tverticalWidgetRange.delta(-this._lineRangeInfo.top),\n\t\t\t\t\tthis.availableSpaceSizesTransposed\n\t\t\t\t);\n\t\t\t\tif (maxWidth < layoutConstants.minWidgetWidth) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tconst horizontalWidgetRange = OffsetRange.ofStartAndLength(editorTrueContentRight - maxWidth, maxWidth);\n\t\t\t\treturn { horizontalWidgetRange, verticalWidgetRange };\n\t\t\t}\n\t\t);\n\t}\n}\n/**\n * Splits line size information into continuous ranges, breaking at positions where\n * the expected vertical position differs from the actual position (e.g., due to folded regions).\n */\nexport function splitIntoContinuousLineRanges(\n\tlineRange: LineRange,\n\tsizes: Size2D[],\n\ttop: number,\n\teditorObs: ObservableCodeEditor,\n\treader: IReader,\n): ContinuousLineSizes[] {\n\tconst result: ContinuousLineSizes[] = [];\n\tlet currentRangeStart = lineRange.startLineNumber;\n\tlet currentRangeTop = top;\n\tlet currentSizes: Size2D[] = [];\n\n\tfor (let i = 0; i < sizes.length; i++) {\n\t\tconst lineNumber = lineRange.startLineNumber + i;\n\t\tconst expectedTop = currentRangeTop + currentSizes.reduce((p, c) => p + c.height, 0);\n\t\tconst actualTop = editorObs.editor.getTopForLineNumber(lineNumber);\n\n\t\tif (i > 0 && actualTop !== expectedTop) {\n\t\t\t// Discontinuity detected - push the current range and start a new one\n\t\t\tresult.push({\n\t\t\t\tlineRange: LineRange.ofLength(currentRangeStart, lineNumber - currentRangeStart),\n\t\t\t\ttop: currentRangeTop,\n\t\t\t\tsizes: currentSizes,\n\t\t\t});\n\t\t\tcurrentRangeStart = lineNumber;\n\t\t\tcurrentRangeTop = actualTop;\n\t\t\tcurrentSizes = [];\n\t\t}\n\t\tcurrentSizes.push(sizes[i]);\n\t}\n\n\t// Push the final range\n\tresult.push({\n\t\tlineRange: LineRange.ofLength(currentRangeStart, lineRange.endLineNumberExclusive - currentRangeStart),\n\t\ttop: currentRangeTop,\n\t\tsizes: currentSizes,\n\t});\n\n\t// Don't observe each line individually for performance reasons\n\tderived({ owner: 'splitIntoContinuousLineRanges' }, r => {\n\t\treturn editorObs.observeTopForLineNumber(lineRange.endLineNumberExclusive - 1).read(r);\n\t}).read(reader);\n\n\treturn result;\n}\n\nfunction findFirstMinimzeDistance<T>(range: LineRange, targetLine: number, predicate: (lineNumber: number) => T | undefined): T | undefined {\n\tfor (let offset = 0; ; offset++) {\n\t\tconst down = targetLine + offset;\n\t\tif (down <= range.endLineNumberExclusive) {\n\t\t\tconst result = predicate(down);\n\t\t\tif (result !== undefined) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\tconst up = targetLine - offset;\n\t\tif (up >= range.startLineNumber) {\n\t\t\tconst result = predicate(up);\n\t\t\tif (result !== undefined) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\tif (up < range.startLineNumber && down > range.endLineNumberExclusive) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n}\n\nfunction getSums<T>(array: T[], fn: (item: T) => number): number[] {\n\tconst result: number[] = [0];\n\tlet sum = 0;\n\tfor (const item of array) {\n\t\tsum += fn(item);\n\t\tresult.push(sum);\n\t}\n\treturn result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { derived, IReader } from '../../../../../../../../base/common/observable.js';\nimport { ObservableCodeEditor } from '../../../../../../../browser/observableCodeEditor.js';\nimport { Size2D } from '../../../../../../../common/core/2d/size.js';\nimport { LineRange } from '../../../../../../../common/core/ranges/lineRange.js';\nimport { OffsetRange } from '../../../../../../../common/core/ranges/offsetRange.js';\nimport { getMaxTowerHeightInAvailableArea } from '../../utils/towersLayout.js';\n\n/**\n * Layout constants used for the long-distance hint widget.\n */\nexport interface WidgetLayoutConstants {\n\treadonly previewEditorMargin: number;\n\treadonly widgetPadding: number;\n\treadonly widgetBorder: number;\n\treadonly lowerBarHeight: number;\n\treadonly minWidgetWidth: number;\n}\n/**\n * Represents a widget placement outline with horizontal and vertical ranges.\n */\nexport interface WidgetOutline {\n\treadonly horizontalWidgetRange: OffsetRange;\n\treadonly verticalWidgetRange: OffsetRange;\n}\n/**\n * Represents a continuous range of lines with their sizes and positioning.\n * Used to compute available space for widget placement.\n */\nexport interface ContinuousLineSizes {\n\treadonly lineRange: LineRange;\n\treadonly top: number;\n\treadonly sizes: Size2D[];\n}\n/**\n * Context for computing widget placement within a continuous line range.\n */\nexport class WidgetPlacementContext {\n\tpublic readonly availableSpaceSizes: Size2D[];\n\tpublic readonly availableSpaceHeightPrefixSums: number[];\n\tpublic readonly availableSpaceSizesTransposed: Size2D[];\n\n\tconstructor(\n\t\tprivate readonly _lineRangeInfo: ContinuousLineSizes,\n\t\teditorTrueContentWidth: number,\n\t\tendOfLinePadding: (lineNumber: number) => number,\n\t) {\n\t\tthis.availableSpaceSizes = _lineRangeInfo.sizes.map((s, idx) => {\n\t\t\tconst lineNumber = _lineRangeInfo.lineRange.startLineNumber + idx;\n\t\t\tconst linePaddingLeft = endOfLinePadding(lineNumber);\n\t\t\treturn new Size2D(Math.max(0, editorTrueContentWidth - s.width - linePaddingLeft), s.height);\n\t\t});\n\n\t\tthis.availableSpaceHeightPrefixSums = getSums(this.availableSpaceSizes, s => s.height);\n\t\tthis.availableSpaceSizesTransposed = this.availableSpaceSizes.map(s => s.transpose());\n\t}\n\n\t/**\n\t * Computes the vertical outline for a widget placed at the given line number.\n\t */\n\tpublic getWidgetVerticalOutline(\n\t\tlineNumber: number,\n\t\tpreviewEditorHeight: number,\n\t\tlayoutConstants: WidgetLayoutConstants\n\t): OffsetRange {\n\t\tconst sizeIdx = lineNumber - this._lineRangeInfo.lineRange.startLineNumber;\n\t\tconst top = this._lineRangeInfo.top + this.availableSpaceHeightPrefixSums[sizeIdx];\n\t\tconst editorRange = OffsetRange.ofStartAndLength(top, previewEditorHeight);\n\t\tconst { previewEditorMargin, widgetPadding, widgetBorder, lowerBarHeight } = layoutConstants;\n\t\tconst verticalWidgetRange = editorRange.withMargin(previewEditorMargin + widgetPadding + widgetBorder).withMargin(0, lowerBarHeight);\n\t\treturn verticalWidgetRange;\n\t}\n\n\t/**\n\t * Tries to find a valid widget outline within this line range context.\n\t */\n\tpublic tryFindWidgetOutline(\n\t\ttargetLineNumber: number,\n\t\tpreviewEditorHeight: number,\n\t\teditorTrueContentRight: number,\n\t\tlayoutConstants: WidgetLayoutConstants\n\t): WidgetOutline | undefined {\n\t\tif (this._lineRangeInfo.lineRange.length < 3) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn findFirstMinimzeDistance(\n\t\t\tthis._lineRangeInfo.lineRange.addMargin(-1, -1),\n\t\t\ttargetLineNumber,\n\t\t\tlineNumber => {\n\t\t\t\tconst verticalWidgetRange = this.getWidgetVerticalOutline(lineNumber, previewEditorHeight, layoutConstants);\n\t\t\t\tconst maxWidth = getMaxTowerHeightInAvailableArea(\n\t\t\t\t\tverticalWidgetRange.delta(-this._lineRangeInfo.top),\n\t\t\t\t\tthis.availableSpaceSizesTransposed\n\t\t\t\t);\n\t\t\t\tif (maxWidth < layoutConstants.minWidgetWidth) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tconst horizontalWidgetRange = OffsetRange.ofStartAndLength(editorTrueContentRight - maxWidth, maxWidth);\n\t\t\t\treturn { horizontalWidgetRange, verticalWidgetRange };\n\t\t\t}\n\t\t);\n\t}\n}\n/**\n * Splits line size information into continuous ranges, breaking at positions where\n * the expected vertical position differs from the actual position (e.g., due to folded regions).\n */\nexport function splitIntoContinuousLineRanges(\n\tlineRange: LineRange,\n\tsizes: Size2D[],\n\ttop: number,\n\teditorObs: ObservableCodeEditor,\n\treader: IReader,\n): ContinuousLineSizes[] {\n\tconst result: ContinuousLineSizes[] = [];\n\tlet currentRangeStart = lineRange.startLineNumber;\n\tlet currentRangeTop = top;\n\tlet currentSizes: Size2D[] = [];\n\n\tfor (let i = 0; i < sizes.length; i++) {\n\t\tconst lineNumber = lineRange.startLineNumber + i;\n\t\tconst expectedTop = currentRangeTop + currentSizes.reduce((p, c) => p + c.height, 0);\n\t\tconst actualTop = editorObs.editor.getTopForLineNumber(lineNumber);\n\n\t\tif (i > 0 && actualTop !== expectedTop) {\n\t\t\t// Discontinuity detected - push the current range and start a new one\n\t\t\tresult.push({\n\t\t\t\tlineRange: LineRange.ofLength(currentRangeStart, lineNumber - currentRangeStart),\n\t\t\t\ttop: currentRangeTop,\n\t\t\t\tsizes: currentSizes,\n\t\t\t});\n\t\t\tcurrentRangeStart = lineNumber;\n\t\t\tcurrentRangeTop = actualTop;\n\t\t\tcurrentSizes = [];\n\t\t}\n\t\tcurrentSizes.push(sizes[i]);\n\t}\n\n\t// Push the final range\n\tresult.push({\n\t\tlineRange: LineRange.ofLength(currentRangeStart, lineRange.endLineNumberExclusive - currentRangeStart),\n\t\ttop: currentRangeTop,\n\t\tsizes: currentSizes,\n\t});\n\n\t// Don't observe each line individually for performance reasons\n\tderived({ owner: 'splitIntoContinuousLineRanges' }, r => {\n\t\treturn editorObs.observeTopForLineNumber(lineRange.endLineNumberExclusive - 1).read(r);\n\t}).read(reader);\n\n\treturn result;\n}\n\nfunction findFirstMinimzeDistance<T>(range: LineRange, targetLine: number, predicate: (lineNumber: number) => T | undefined): T | undefined {\n\tfor (let offset = 0; ; offset++) {\n\t\tconst down = targetLine + offset;\n\t\tif (down <= range.endLineNumberExclusive) {\n\t\t\tconst result = predicate(down);\n\t\t\tif (result !== undefined) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\tconst up = targetLine - offset;\n\t\tif (up >= range.startLineNumber) {\n\t\t\tconst result = predicate(up);\n\t\t\tif (result !== undefined) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\tif (up < range.startLineNumber && down > range.endLineNumberExclusive) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n}\n\nfunction getSums<T>(array: T[], fn: (item: T) => number): number[] {\n\tconst result: number[] = [0];\n\tlet sum = 0;\n\tfor (const item of array) {\n\t\tsum += fn(item);\n\t\tresult.push(sum);\n\t}\n\treturn result;\n}\n"]}