{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/css/decorationCssRuleExtractor.ts","vs/editor/browser/gpu/css/decorationCssRuleExtractor.ts"],"names":[],"mappings":"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","file":"decorationCssRuleExtractor.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { $, getActiveDocument, getActiveWindow } from '../../../../base/browser/dom.js';\nimport { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport './media/decorationCssRuleExtractor.css';\n\n/**\n * Extracts CSS rules that would be applied to certain decoration classes.\n */\nexport class DecorationCssRuleExtractor extends Disposable {\n\tprivate _container: HTMLElement;\n\tprivate _dummyElement: HTMLSpanElement;\n\n\tprivate _ruleCache: Map</* className */string, CSSStyleRule[]> = new Map();\n\tprivate _cssVariableCache: Map</* variableName */string, /* value */string> = new Map();\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis._container = $('div.monaco-decoration-css-rule-extractor');\n\t\tthis._dummyElement = $('span');\n\t\tthis._container.appendChild(this._dummyElement);\n\n\t\tthis._register(toDisposable(() => this._container.remove()));\n\t}\n\n\tgetStyleRules(canvas: HTMLElement, decorationClassName: string): CSSStyleRule[] {\n\t\t// Check cache\n\t\tconst existing = this._ruleCache.get(decorationClassName);\n\t\tif (existing) {\n\t\t\treturn existing;\n\t\t}\n\n\t\t// Set up DOM\n\t\tthis._dummyElement.className = decorationClassName;\n\t\tcanvas.appendChild(this._container);\n\n\t\t// Get rules\n\t\tconst rules = this._getStyleRules(decorationClassName);\n\t\tthis._ruleCache.set(decorationClassName, rules);\n\n\t\t// Tear down DOM\n\t\tcanvas.removeChild(this._container);\n\n\t\treturn rules;\n\t}\n\n\tprivate _getStyleRules(className: string) {\n\t\t// Iterate through all stylesheets and imported stylesheets to find matching rules\n\t\tconst rules: CSSStyleRule[] = [];\n\t\tconst doc = getActiveDocument();\n\t\tconst stylesheets = [...doc.styleSheets];\n\n\t\t// className can be space-separated (e.g., 'ghost-text-decoration syntax-highlighted')\n\t\t// We need to search for each individual class\n\t\tconst classNames = className.split(' ').filter(c => c.length > 0);\n\n\t\tfor (let i = 0; i < stylesheets.length; i++) {\n\t\t\tconst stylesheet = stylesheets[i];\n\t\t\tthis._collectMatchingRules(stylesheet.cssRules, classNames, rules);\n\t\t}\n\n\t\treturn rules;\n\t}\n\n\tprivate _collectMatchingRules(cssRules: CSSRuleList, classNames: string[], result: CSSStyleRule[]): void {\n\t\tfor (const rule of cssRules) {\n\t\t\tif (rule instanceof CSSImportRule) {\n\t\t\t\tif (rule.styleSheet) {\n\t\t\t\t\tthis._collectMatchingRules(rule.styleSheet.cssRules, classNames, result);\n\t\t\t\t}\n\t\t\t} else if (rule instanceof CSSStyleRule) {\n\t\t\t\t// Note that originally `.matches(rule.selectorText)` was used but this would\n\t\t\t\t// not pick up pseudo-classes which are important to determine support of the\n\t\t\t\t// returned styles.\n\t\t\t\t//\n\t\t\t\t// Since a selector could contain a class name lookup that is simple a prefix of\n\t\t\t\t// the class name we are looking for, we need to also check the character after\n\t\t\t\t// it.\n\t\t\t\tfor (const className of classNames) {\n\t\t\t\t\tconst searchTerm = `.${className}`;\n\t\t\t\t\tconst index = rule.selectorText.indexOf(searchTerm);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tconst endOfResult = index + searchTerm.length;\n\t\t\t\t\t\tif (rule.selectorText.length === endOfResult || rule.selectorText.substring(endOfResult, endOfResult + 1).match(/[ :.]/)) {\n\t\t\t\t\t\t\tresult.push(rule);\n\t\t\t\t\t\t\tbreak; // Don't add the same rule multiple times\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Recursively check nested rules (CSS nesting)\n\t\t\t\tif (rule.cssRules?.length) {\n\t\t\t\t\tthis._collectMatchingRules(rule.cssRules, classNames, result);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Resolves a CSS variable to its computed value using the container element.\n\t */\n\tresolveCssVariable(canvas: HTMLCanvasElement, variableName: string): string {\n\t\tlet result = this._cssVariableCache.get(variableName);\n\t\tif (result === undefined) {\n\t\t\tcanvas.appendChild(this._container);\n\t\t\tresult = getActiveWindow().getComputedStyle(this._container).getPropertyValue(variableName).trim();\n\t\t\tcanvas.removeChild(this._container);\n\t\t\tthis._cssVariableCache.set(variableName, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Clears all cached CSS rules and CSS variable values. This should be called when the theme\n\t * changes to ensure fresh values are computed.\n\t */\n\tclear(): void {\n\t\tthis._ruleCache.clear();\n\t\tthis._cssVariableCache.clear();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { $, getActiveDocument, getActiveWindow } from '../../../../base/browser/dom.js';\nimport { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport './media/decorationCssRuleExtractor.css';\n\n/**\n * Extracts CSS rules that would be applied to certain decoration classes.\n */\nexport class DecorationCssRuleExtractor extends Disposable {\n\tprivate _container: HTMLElement;\n\tprivate _dummyElement: HTMLSpanElement;\n\n\tprivate _ruleCache: Map</* className */string, CSSStyleRule[]> = new Map();\n\tprivate _cssVariableCache: Map</* variableName */string, /* value */string> = new Map();\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis._container = $('div.monaco-decoration-css-rule-extractor');\n\t\tthis._dummyElement = $('span');\n\t\tthis._container.appendChild(this._dummyElement);\n\n\t\tthis._register(toDisposable(() => this._container.remove()));\n\t}\n\n\tgetStyleRules(canvas: HTMLElement, decorationClassName: string): CSSStyleRule[] {\n\t\t// Check cache\n\t\tconst existing = this._ruleCache.get(decorationClassName);\n\t\tif (existing) {\n\t\t\treturn existing;\n\t\t}\n\n\t\t// Set up DOM\n\t\tthis._dummyElement.className = decorationClassName;\n\t\tcanvas.appendChild(this._container);\n\n\t\t// Get rules\n\t\tconst rules = this._getStyleRules(decorationClassName);\n\t\tthis._ruleCache.set(decorationClassName, rules);\n\n\t\t// Tear down DOM\n\t\tcanvas.removeChild(this._container);\n\n\t\treturn rules;\n\t}\n\n\tprivate _getStyleRules(className: string) {\n\t\t// Iterate through all stylesheets and imported stylesheets to find matching rules\n\t\tconst rules: CSSStyleRule[] = [];\n\t\tconst doc = getActiveDocument();\n\t\tconst stylesheets = [...doc.styleSheets];\n\n\t\t// className can be space-separated (e.g., 'ghost-text-decoration syntax-highlighted')\n\t\t// We need to search for each individual class\n\t\tconst classNames = className.split(' ').filter(c => c.length > 0);\n\n\t\tfor (let i = 0; i < stylesheets.length; i++) {\n\t\t\tconst stylesheet = stylesheets[i];\n\t\t\tthis._collectMatchingRules(stylesheet.cssRules, classNames, rules);\n\t\t}\n\n\t\treturn rules;\n\t}\n\n\tprivate _collectMatchingRules(cssRules: CSSRuleList, classNames: string[], result: CSSStyleRule[]): void {\n\t\tfor (const rule of cssRules) {\n\t\t\tif (rule instanceof CSSImportRule) {\n\t\t\t\tif (rule.styleSheet) {\n\t\t\t\t\tthis._collectMatchingRules(rule.styleSheet.cssRules, classNames, result);\n\t\t\t\t}\n\t\t\t} else if (rule instanceof CSSStyleRule) {\n\t\t\t\t// Note that originally `.matches(rule.selectorText)` was used but this would\n\t\t\t\t// not pick up pseudo-classes which are important to determine support of the\n\t\t\t\t// returned styles.\n\t\t\t\t//\n\t\t\t\t// Since a selector could contain a class name lookup that is simple a prefix of\n\t\t\t\t// the class name we are looking for, we need to also check the character after\n\t\t\t\t// it.\n\t\t\t\tfor (const className of classNames) {\n\t\t\t\t\tconst searchTerm = `.${className}`;\n\t\t\t\t\tconst index = rule.selectorText.indexOf(searchTerm);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tconst endOfResult = index + searchTerm.length;\n\t\t\t\t\t\tif (rule.selectorText.length === endOfResult || rule.selectorText.substring(endOfResult, endOfResult + 1).match(/[ :.]/)) {\n\t\t\t\t\t\t\tresult.push(rule);\n\t\t\t\t\t\t\tbreak; // Don't add the same rule multiple times\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Recursively check nested rules (CSS nesting)\n\t\t\t\tif (rule.cssRules?.length) {\n\t\t\t\t\tthis._collectMatchingRules(rule.cssRules, classNames, result);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Resolves a CSS variable to its computed value using the container element.\n\t */\n\tresolveCssVariable(canvas: HTMLCanvasElement, variableName: string): string {\n\t\tlet result = this._cssVariableCache.get(variableName);\n\t\tif (result === undefined) {\n\t\t\tcanvas.appendChild(this._container);\n\t\t\tresult = getActiveWindow().getComputedStyle(this._container).getPropertyValue(variableName).trim();\n\t\t\tcanvas.removeChild(this._container);\n\t\t\tthis._cssVariableCache.set(variableName, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Clears all cached CSS rules and CSS variable values. This should be called when the theme\n\t * changes to ensure fresh values are computed.\n\t */\n\tclear(): void {\n\t\tthis._ruleCache.clear();\n\t\tthis._cssVariableCache.clear();\n\t}\n}\n"]}