{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/tokens/annotations.ts","vs/editor/common/model/tokens/annotations.ts"],"names":[],"mappings":"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","file":"annotations.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { binarySearch2 } from '../../../../base/common/arrays.js';\nimport { StringEdit } from '../../core/edits/stringEdit.js';\nimport { OffsetRange } from '../../core/ranges/offsetRange.js';\n\nexport interface IAnnotation<T> {\n\trange: OffsetRange;\n\tannotation: T;\n}\n\nexport interface IAnnotatedString<T> {\n\t/**\n\t * Set annotations for a specific line.\n\t * Annotations should be sorted and non-overlapping.\n\t */\n\tsetAnnotations(annotations: AnnotationsUpdate<T>): void;\n\t/**\n\t * Return annotations intersecting with the given offset range.\n\t */\n\tgetAnnotationsIntersecting(range: OffsetRange): IAnnotation<T>[];\n\t/**\n\t * Apply a string edit to the annotated string.\n\t * @returns The annotations that were deleted (became empty) as a result of the edit.\n\t */\n\tapplyEdit(edit: StringEdit): IAnnotation<T>[];\n}\n\nexport class AnnotatedString<T> implements IAnnotatedString<T> {\n\n\t/**\n\t * Annotations are non intersecting and contiguous in the array.\n\t */\n\tprivate _annotations: IAnnotation<T>[] = [];\n\n\tconstructor(annotations: IAnnotation<T>[] = []) {\n\t\tthis._annotations = annotations;\n\t}\n\n\t/**\n\t * Set annotations for a specific range.\n\t * Annotations should be sorted and non-overlapping.\n\t * If the annotation value is undefined, the annotation is removed.\n\t */\n\tpublic setAnnotations(annotations: AnnotationsUpdate<T>): void {\n\t\tfor (const annotation of annotations.annotations) {\n\t\t\tconst startIndex = this._getStartIndexOfIntersectingAnnotation(annotation.range.start);\n\t\t\tconst endIndexExclusive = this._getEndIndexOfIntersectingAnnotation(annotation.range.endExclusive);\n\t\t\tif (annotation.annotation !== undefined) {\n\t\t\t\tthis._annotations.splice(startIndex, endIndexExclusive - startIndex, { range: annotation.range, annotation: annotation.annotation });\n\t\t\t} else {\n\t\t\t\tthis._annotations.splice(startIndex, endIndexExclusive - startIndex);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns all annotations that intersect with the given offset range.\n\t */\n\tpublic getAnnotationsIntersecting(range: OffsetRange): IAnnotation<T>[] {\n\t\tconst startIndex = this._getStartIndexOfIntersectingAnnotation(range.start);\n\t\tconst endIndexExclusive = this._getEndIndexOfIntersectingAnnotation(range.endExclusive);\n\t\treturn this._annotations.slice(startIndex, endIndexExclusive);\n\t}\n\n\tprivate _getStartIndexOfIntersectingAnnotation(offset: number): number {\n\t\t// Find index to the left of the offset\n\t\tconst startIndexWhereToReplace = binarySearch2(this._annotations.length, (index) => {\n\t\t\treturn this._annotations[index].range.start - offset;\n\t\t});\n\t\tlet startIndex: number;\n\t\tif (startIndexWhereToReplace >= 0) {\n\t\t\tstartIndex = startIndexWhereToReplace;\n\t\t} else {\n\t\t\tconst candidate = this._annotations[- (startIndexWhereToReplace + 2)]?.range;\n\t\t\tif (candidate && offset >= candidate.start && offset < candidate.endExclusive) {\n\t\t\t\tstartIndex = - (startIndexWhereToReplace + 2);\n\t\t\t} else {\n\t\t\t\tstartIndex = - (startIndexWhereToReplace + 1);\n\t\t\t}\n\t\t}\n\t\treturn startIndex;\n\t}\n\n\tprivate _getEndIndexOfIntersectingAnnotation(offset: number): number {\n\t\t// Find index to the right of the offset\n\t\tconst endIndexWhereToReplace = binarySearch2(this._annotations.length, (index) => {\n\t\t\treturn this._annotations[index].range.endExclusive - offset;\n\t\t});\n\t\tlet endIndexExclusive: number;\n\t\tif (endIndexWhereToReplace >= 0) {\n\t\t\tendIndexExclusive = endIndexWhereToReplace + 1;\n\t\t} else {\n\t\t\tconst candidate = this._annotations[-(endIndexWhereToReplace + 1)]?.range;\n\t\t\tif (candidate && offset > candidate.start && offset <= candidate.endExclusive) {\n\t\t\t\tendIndexExclusive = - endIndexWhereToReplace;\n\t\t\t} else {\n\t\t\t\tendIndexExclusive = - (endIndexWhereToReplace + 1);\n\t\t\t}\n\t\t}\n\t\treturn endIndexExclusive;\n\t}\n\n\t/**\n\t * Applies a string edit to the annotated string, updating annotation ranges accordingly.\n\t * @param edit The string edit to apply.\n\t * @returns The annotations that were deleted (became empty) as a result of the edit.\n\t */\n\tpublic applyEdit(edit: StringEdit): IAnnotation<T>[] {\n\t\tconst annotations = this._annotations.slice();\n\n\t\t// treat edits as deletion of the replace range and then as insertion that extends the first range\n\t\tconst finalAnnotations: IAnnotation<T>[] = [];\n\t\tconst deletedAnnotations: IAnnotation<T>[] = [];\n\n\t\tlet offset = 0;\n\n\t\tfor (const e of edit.replacements) {\n\t\t\twhile (true) {\n\t\t\t\t// ranges before the current edit\n\t\t\t\tconst annotation = annotations[0];\n\t\t\t\tif (!annotation) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst range = annotation.range;\n\t\t\t\tif (range.endExclusive >= e.replaceRange.start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tannotations.shift();\n\t\t\t\tconst newAnnotation = { range: range.delta(offset), annotation: annotation.annotation };\n\t\t\t\tif (!newAnnotation.range.isEmpty) {\n\t\t\t\t\tfinalAnnotations.push(newAnnotation);\n\t\t\t\t} else {\n\t\t\t\t\tdeletedAnnotations.push(newAnnotation);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst intersecting: IAnnotation<T>[] = [];\n\t\t\twhile (true) {\n\t\t\t\tconst annotation = annotations[0];\n\t\t\t\tif (!annotation) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst range = annotation.range;\n\t\t\t\tif (!range.intersectsOrTouches(e.replaceRange)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tannotations.shift();\n\t\t\t\tintersecting.push(annotation);\n\t\t\t}\n\n\t\t\tfor (let i = intersecting.length - 1; i >= 0; i--) {\n\t\t\t\tconst annotation = intersecting[i];\n\t\t\t\tlet r = annotation.range;\n\n\t\t\t\t// Inserted text will extend the first intersecting annotation, if the edit truly overlaps it\n\t\t\t\tconst shouldExtend = i === 0 && (e.replaceRange.endExclusive > r.start) && (e.replaceRange.start < r.endExclusive);\n\t\t\t\t// Annotation shrinks by the overlap then grows with the new text length\n\t\t\t\tconst overlap = r.intersect(e.replaceRange)!.length;\n\t\t\t\tr = r.deltaEnd(-overlap + (shouldExtend ? e.newText.length : 0));\n\n\t\t\t\t// If the annotation starts after the edit start, shift left to the edit start position\n\t\t\t\tconst rangeAheadOfReplaceRange = r.start - e.replaceRange.start;\n\t\t\t\tif (rangeAheadOfReplaceRange > 0) {\n\t\t\t\t\tr = r.delta(-rangeAheadOfReplaceRange);\n\t\t\t\t}\n\n\t\t\t\t// If annotation shouldn't be extended AND it is after or on edit start, move it after the newly inserted text\n\t\t\t\tif (!shouldExtend && rangeAheadOfReplaceRange >= 0) {\n\t\t\t\t\tr = r.delta(e.newText.length);\n\t\t\t\t}\n\n\t\t\t\t// We already took our offset into account.\n\t\t\t\t// Because we add r back to the queue (which then adds offset again),\n\t\t\t\t// we have to remove it here so as to not double count it.\n\t\t\t\tr = r.delta(-(e.newText.length - e.replaceRange.length));\n\n\t\t\t\tannotations.unshift({ annotation: annotation.annotation, range: r });\n\t\t\t}\n\n\t\t\toffset += e.newText.length - e.replaceRange.length;\n\t\t}\n\n\t\twhile (true) {\n\t\t\tconst annotation = annotations[0];\n\t\t\tif (!annotation) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tannotations.shift();\n\t\t\tconst newAnnotation = { annotation: annotation.annotation, range: annotation.range.delta(offset) };\n\t\t\tif (!newAnnotation.range.isEmpty) {\n\t\t\t\tfinalAnnotations.push(newAnnotation);\n\t\t\t} else {\n\t\t\t\tdeletedAnnotations.push(newAnnotation);\n\t\t\t}\n\t\t}\n\t\tthis._annotations = finalAnnotations;\n\t\treturn deletedAnnotations;\n\t}\n}\n\nexport interface IAnnotationUpdate<T> {\n\trange: OffsetRange;\n\tannotation: T | undefined;\n}\n\nexport class AnnotationsUpdate<T> {\n\n\tpublic static create<T>(annotations: IAnnotationUpdate<T>[]): AnnotationsUpdate<T> {\n\t\treturn new AnnotationsUpdate(annotations);\n\t}\n\n\tprivate _annotations: IAnnotationUpdate<T>[];\n\n\tprivate constructor(annotations: IAnnotationUpdate<T>[]) {\n\t\tthis._annotations = annotations;\n\t}\n\n\tget annotations(): IAnnotationUpdate<T>[] {\n\t\treturn this._annotations;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { binarySearch2 } from '../../../../base/common/arrays.js';\nimport { StringEdit } from '../../core/edits/stringEdit.js';\nimport { OffsetRange } from '../../core/ranges/offsetRange.js';\n\nexport interface IAnnotation<T> {\n\trange: OffsetRange;\n\tannotation: T;\n}\n\nexport interface IAnnotatedString<T> {\n\t/**\n\t * Set annotations for a specific line.\n\t * Annotations should be sorted and non-overlapping.\n\t */\n\tsetAnnotations(annotations: AnnotationsUpdate<T>): void;\n\t/**\n\t * Return annotations intersecting with the given offset range.\n\t */\n\tgetAnnotationsIntersecting(range: OffsetRange): IAnnotation<T>[];\n\t/**\n\t * Apply a string edit to the annotated string.\n\t * @returns The annotations that were deleted (became empty) as a result of the edit.\n\t */\n\tapplyEdit(edit: StringEdit): IAnnotation<T>[];\n}\n\nexport class AnnotatedString<T> implements IAnnotatedString<T> {\n\n\t/**\n\t * Annotations are non intersecting and contiguous in the array.\n\t */\n\tprivate _annotations: IAnnotation<T>[] = [];\n\n\tconstructor(annotations: IAnnotation<T>[] = []) {\n\t\tthis._annotations = annotations;\n\t}\n\n\t/**\n\t * Set annotations for a specific range.\n\t * Annotations should be sorted and non-overlapping.\n\t * If the annotation value is undefined, the annotation is removed.\n\t */\n\tpublic setAnnotations(annotations: AnnotationsUpdate<T>): void {\n\t\tfor (const annotation of annotations.annotations) {\n\t\t\tconst startIndex = this._getStartIndexOfIntersectingAnnotation(annotation.range.start);\n\t\t\tconst endIndexExclusive = this._getEndIndexOfIntersectingAnnotation(annotation.range.endExclusive);\n\t\t\tif (annotation.annotation !== undefined) {\n\t\t\t\tthis._annotations.splice(startIndex, endIndexExclusive - startIndex, { range: annotation.range, annotation: annotation.annotation });\n\t\t\t} else {\n\t\t\t\tthis._annotations.splice(startIndex, endIndexExclusive - startIndex);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns all annotations that intersect with the given offset range.\n\t */\n\tpublic getAnnotationsIntersecting(range: OffsetRange): IAnnotation<T>[] {\n\t\tconst startIndex = this._getStartIndexOfIntersectingAnnotation(range.start);\n\t\tconst endIndexExclusive = this._getEndIndexOfIntersectingAnnotation(range.endExclusive);\n\t\treturn this._annotations.slice(startIndex, endIndexExclusive);\n\t}\n\n\tprivate _getStartIndexOfIntersectingAnnotation(offset: number): number {\n\t\t// Find index to the left of the offset\n\t\tconst startIndexWhereToReplace = binarySearch2(this._annotations.length, (index) => {\n\t\t\treturn this._annotations[index].range.start - offset;\n\t\t});\n\t\tlet startIndex: number;\n\t\tif (startIndexWhereToReplace >= 0) {\n\t\t\tstartIndex = startIndexWhereToReplace;\n\t\t} else {\n\t\t\tconst candidate = this._annotations[- (startIndexWhereToReplace + 2)]?.range;\n\t\t\tif (candidate && offset >= candidate.start && offset < candidate.endExclusive) {\n\t\t\t\tstartIndex = - (startIndexWhereToReplace + 2);\n\t\t\t} else {\n\t\t\t\tstartIndex = - (startIndexWhereToReplace + 1);\n\t\t\t}\n\t\t}\n\t\treturn startIndex;\n\t}\n\n\tprivate _getEndIndexOfIntersectingAnnotation(offset: number): number {\n\t\t// Find index to the right of the offset\n\t\tconst endIndexWhereToReplace = binarySearch2(this._annotations.length, (index) => {\n\t\t\treturn this._annotations[index].range.endExclusive - offset;\n\t\t});\n\t\tlet endIndexExclusive: number;\n\t\tif (endIndexWhereToReplace >= 0) {\n\t\t\tendIndexExclusive = endIndexWhereToReplace + 1;\n\t\t} else {\n\t\t\tconst candidate = this._annotations[-(endIndexWhereToReplace + 1)]?.range;\n\t\t\tif (candidate && offset > candidate.start && offset <= candidate.endExclusive) {\n\t\t\t\tendIndexExclusive = - endIndexWhereToReplace;\n\t\t\t} else {\n\t\t\t\tendIndexExclusive = - (endIndexWhereToReplace + 1);\n\t\t\t}\n\t\t}\n\t\treturn endIndexExclusive;\n\t}\n\n\t/**\n\t * Applies a string edit to the annotated string, updating annotation ranges accordingly.\n\t * @param edit The string edit to apply.\n\t * @returns The annotations that were deleted (became empty) as a result of the edit.\n\t */\n\tpublic applyEdit(edit: StringEdit): IAnnotation<T>[] {\n\t\tconst annotations = this._annotations.slice();\n\n\t\t// treat edits as deletion of the replace range and then as insertion that extends the first range\n\t\tconst finalAnnotations: IAnnotation<T>[] = [];\n\t\tconst deletedAnnotations: IAnnotation<T>[] = [];\n\n\t\tlet offset = 0;\n\n\t\tfor (const e of edit.replacements) {\n\t\t\twhile (true) {\n\t\t\t\t// ranges before the current edit\n\t\t\t\tconst annotation = annotations[0];\n\t\t\t\tif (!annotation) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst range = annotation.range;\n\t\t\t\tif (range.endExclusive >= e.replaceRange.start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tannotations.shift();\n\t\t\t\tconst newAnnotation = { range: range.delta(offset), annotation: annotation.annotation };\n\t\t\t\tif (!newAnnotation.range.isEmpty) {\n\t\t\t\t\tfinalAnnotations.push(newAnnotation);\n\t\t\t\t} else {\n\t\t\t\t\tdeletedAnnotations.push(newAnnotation);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst intersecting: IAnnotation<T>[] = [];\n\t\t\twhile (true) {\n\t\t\t\tconst annotation = annotations[0];\n\t\t\t\tif (!annotation) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst range = annotation.range;\n\t\t\t\tif (!range.intersectsOrTouches(e.replaceRange)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tannotations.shift();\n\t\t\t\tintersecting.push(annotation);\n\t\t\t}\n\n\t\t\tfor (let i = intersecting.length - 1; i >= 0; i--) {\n\t\t\t\tconst annotation = intersecting[i];\n\t\t\t\tlet r = annotation.range;\n\n\t\t\t\t// Inserted text will extend the first intersecting annotation, if the edit truly overlaps it\n\t\t\t\tconst shouldExtend = i === 0 && (e.replaceRange.endExclusive > r.start) && (e.replaceRange.start < r.endExclusive);\n\t\t\t\t// Annotation shrinks by the overlap then grows with the new text length\n\t\t\t\tconst overlap = r.intersect(e.replaceRange)!.length;\n\t\t\t\tr = r.deltaEnd(-overlap + (shouldExtend ? e.newText.length : 0));\n\n\t\t\t\t// If the annotation starts after the edit start, shift left to the edit start position\n\t\t\t\tconst rangeAheadOfReplaceRange = r.start - e.replaceRange.start;\n\t\t\t\tif (rangeAheadOfReplaceRange > 0) {\n\t\t\t\t\tr = r.delta(-rangeAheadOfReplaceRange);\n\t\t\t\t}\n\n\t\t\t\t// If annotation shouldn't be extended AND it is after or on edit start, move it after the newly inserted text\n\t\t\t\tif (!shouldExtend && rangeAheadOfReplaceRange >= 0) {\n\t\t\t\t\tr = r.delta(e.newText.length);\n\t\t\t\t}\n\n\t\t\t\t// We already took our offset into account.\n\t\t\t\t// Because we add r back to the queue (which then adds offset again),\n\t\t\t\t// we have to remove it here so as to not double count it.\n\t\t\t\tr = r.delta(-(e.newText.length - e.replaceRange.length));\n\n\t\t\t\tannotations.unshift({ annotation: annotation.annotation, range: r });\n\t\t\t}\n\n\t\t\toffset += e.newText.length - e.replaceRange.length;\n\t\t}\n\n\t\twhile (true) {\n\t\t\tconst annotation = annotations[0];\n\t\t\tif (!annotation) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tannotations.shift();\n\t\t\tconst newAnnotation = { annotation: annotation.annotation, range: annotation.range.delta(offset) };\n\t\t\tif (!newAnnotation.range.isEmpty) {\n\t\t\t\tfinalAnnotations.push(newAnnotation);\n\t\t\t} else {\n\t\t\t\tdeletedAnnotations.push(newAnnotation);\n\t\t\t}\n\t\t}\n\t\tthis._annotations = finalAnnotations;\n\t\treturn deletedAnnotations;\n\t}\n}\n\nexport interface IAnnotationUpdate<T> {\n\trange: OffsetRange;\n\tannotation: T | undefined;\n}\n\nexport class AnnotationsUpdate<T> {\n\n\tpublic static create<T>(annotations: IAnnotationUpdate<T>[]): AnnotationsUpdate<T> {\n\t\treturn new AnnotationsUpdate(annotations);\n\t}\n\n\tprivate _annotations: IAnnotationUpdate<T>[];\n\n\tprivate constructor(annotations: IAnnotationUpdate<T>[]) {\n\t\tthis._annotations = annotations;\n\t}\n\n\tget annotations(): IAnnotationUpdate<T>[] {\n\t\treturn this._annotations;\n\t}\n}\n"]}