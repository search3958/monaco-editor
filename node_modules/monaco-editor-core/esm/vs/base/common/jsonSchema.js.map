{"version":3,"sources":["file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/jsonSchema.ts","vs/base/common/jsonSchema.ts"],"names":[],"mappings":"AAAA;;;gGAGgG","file":"jsonSchema.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport type JSONSchemaType = 'string' | 'number' | 'integer' | 'boolean' | 'null' | 'array' | 'object';\n\nexport interface IJSONSchema {\n\ttype?: JSONSchemaType | JSONSchemaType[];\n\tdefault?: any;\n\tdefinitions?: IJSONSchemaMap;\n\tdescription?: string;\n\tproperties?: IJSONSchemaMap;\n\tpatternProperties?: IJSONSchemaMap;\n\tadditionalProperties?: boolean | IJSONSchema;\n\titems?: IJSONSchema | IJSONSchema[];\n\tpattern?: string;\n\tminimum?: number;\n\tmaximum?: number;\n\trequired?: string[];\n\t$ref?: string;\n\tanyOf?: IJSONSchema[];\n\toneOf?: IJSONSchema[];\n\tenum?: any[];\n\tformat?: string;\n\n\t// schema draft 06\n\tconst?: any;\n\tdeprecated?: boolean;\n\n\t// VSCode extensions\n\n\tdefaultSnippets?: IJSONSchemaSnippet[];\n\terrorMessage?: string;\n\tpatternErrorMessage?: string;\n\tdeprecationMessage?: string;\n\tmarkdownDeprecationMessage?: string;\n\tenumDescriptions?: string[];\n\tmarkdownEnumDescriptions?: string[];\n\tmarkdownDescription?: string;\n\tallowComments?: boolean;\n\tallowTrailingCommas?: boolean;\n}\n\nexport interface IJSONSchemaMap {\n\t[name: string]: IJSONSchema;\n}\n\nexport interface IJSONSchemaSnippet {\n\tbody?: any; // an already stringified JSON object that can contain new lines (\\n) and tabs (\\t)\n}\n\n/**\n * Converts a basic JSON schema to a TypeScript type.\n */\nexport type TypeFromJsonSchema<T> =\n\t// enum\n\tT extends { enum: infer EnumValues }\n\t? UnionOf<EnumValues>\n\n\t// Object with list of required properties.\n\t// Values are required or optional based on `required` list.\n\t: T extends { type: 'object'; properties: infer P; required: infer RequiredList }\n\t? {\n\t\t[K in keyof P]: IsRequired<K, RequiredList> extends true ? TypeFromJsonSchema<P[K]> : TypeFromJsonSchema<P[K]> | undefined;\n\t} & AdditionalPropertiesType<T>\n\n\t// Object with no required properties.\n\t// All values are optional\n\t: T extends { type: 'object'; properties: infer P }\n\t? { [K in keyof P]: TypeFromJsonSchema<P[K]> | undefined } & AdditionalPropertiesType<T>\n\n\t// Array\n\t: T extends { type: 'array'; items: infer Items }\n\t? Items extends [...infer R]\n\t// If items is an array, we treat it like a tuple\n\t? { [K in keyof R]: TypeFromJsonSchema<Items[K]> }\n\t: Array<TypeFromJsonSchema<Items>>\n\n\t// oneOf / anyof\n\t// These are handled the same way as they both represent a union type.\n\t// However at the validation level, they have different semantics.\n\t: T extends { oneOf: infer I }\n\t? MapSchemaToType<I>\n\t: T extends { anyOf: infer I }\n\t? MapSchemaToType<I>\n\n\t// Primitive types\n\t: T extends { type: infer Type }\n\t// Basic type\n\t? Type extends 'string' | 'number' | 'integer' | 'boolean' | 'null'\n\t? SchemaPrimitiveTypeNameToType<Type>\n\t// Union of primitive types\n\t: Type extends [...infer R]\n\t? UnionOf<{ [K in keyof R]: SchemaPrimitiveTypeNameToType<R[K]> }>\n\t: never\n\n\t// Fallthrough\n\t: never;\n\ntype SchemaPrimitiveTypeNameToType<T> =\n\tT extends 'string' ? string :\n\tT extends 'number' | 'integer' ? number :\n\tT extends 'boolean' ? boolean :\n\tT extends 'null' ? null :\n\tnever;\n\ntype UnionOf<T> =\n\tT extends [infer First, ...infer Rest]\n\t? First | UnionOf<Rest>\n\t: never;\n\ntype IsRequired<K, RequiredList> =\n\tRequiredList extends []\n\t? false\n\n\t: RequiredList extends [K, ...infer _]\n\t? true\n\n\t: RequiredList extends [infer _, ...infer R]\n\t? IsRequired<K, R>\n\n\t: false;\n\ntype AdditionalPropertiesType<Schema> =\n\tSchema extends { additionalProperties: infer AP }\n\t? AP extends false ? {} : { [key: string]: TypeFromJsonSchema<Schema['additionalProperties']> }\n\t: {};\n\ntype MapSchemaToType<T> = T extends [infer First, ...infer Rest]\n\t? TypeFromJsonSchema<First> | MapSchemaToType<Rest>\n\t: never;\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport type JSONSchemaType = 'string' | 'number' | 'integer' | 'boolean' | 'null' | 'array' | 'object';\n\nexport interface IJSONSchema {\n\ttype?: JSONSchemaType | JSONSchemaType[];\n\tdefault?: any;\n\tdefinitions?: IJSONSchemaMap;\n\tdescription?: string;\n\tproperties?: IJSONSchemaMap;\n\tpatternProperties?: IJSONSchemaMap;\n\tadditionalProperties?: boolean | IJSONSchema;\n\titems?: IJSONSchema | IJSONSchema[];\n\tpattern?: string;\n\tminimum?: number;\n\tmaximum?: number;\n\trequired?: string[];\n\t$ref?: string;\n\tanyOf?: IJSONSchema[];\n\toneOf?: IJSONSchema[];\n\tenum?: any[];\n\tformat?: string;\n\n\t// schema draft 06\n\tconst?: any;\n\tdeprecated?: boolean;\n\n\t// VSCode extensions\n\n\tdefaultSnippets?: IJSONSchemaSnippet[];\n\terrorMessage?: string;\n\tpatternErrorMessage?: string;\n\tdeprecationMessage?: string;\n\tmarkdownDeprecationMessage?: string;\n\tenumDescriptions?: string[];\n\tmarkdownEnumDescriptions?: string[];\n\tmarkdownDescription?: string;\n\tallowComments?: boolean;\n\tallowTrailingCommas?: boolean;\n}\n\nexport interface IJSONSchemaMap {\n\t[name: string]: IJSONSchema;\n}\n\nexport interface IJSONSchemaSnippet {\n\tbody?: any; // an already stringified JSON object that can contain new lines (\\n) and tabs (\\t)\n}\n\n/**\n * Converts a basic JSON schema to a TypeScript type.\n */\nexport type TypeFromJsonSchema<T> =\n\t// enum\n\tT extends { enum: infer EnumValues }\n\t? UnionOf<EnumValues>\n\n\t// Object with list of required properties.\n\t// Values are required or optional based on `required` list.\n\t: T extends { type: 'object'; properties: infer P; required: infer RequiredList }\n\t? {\n\t\t[K in keyof P]: IsRequired<K, RequiredList> extends true ? TypeFromJsonSchema<P[K]> : TypeFromJsonSchema<P[K]> | undefined;\n\t} & AdditionalPropertiesType<T>\n\n\t// Object with no required properties.\n\t// All values are optional\n\t: T extends { type: 'object'; properties: infer P }\n\t? { [K in keyof P]: TypeFromJsonSchema<P[K]> | undefined } & AdditionalPropertiesType<T>\n\n\t// Array\n\t: T extends { type: 'array'; items: infer Items }\n\t? Items extends [...infer R]\n\t// If items is an array, we treat it like a tuple\n\t? { [K in keyof R]: TypeFromJsonSchema<Items[K]> }\n\t: Array<TypeFromJsonSchema<Items>>\n\n\t// oneOf / anyof\n\t// These are handled the same way as they both represent a union type.\n\t// However at the validation level, they have different semantics.\n\t: T extends { oneOf: infer I }\n\t? MapSchemaToType<I>\n\t: T extends { anyOf: infer I }\n\t? MapSchemaToType<I>\n\n\t// Primitive types\n\t: T extends { type: infer Type }\n\t// Basic type\n\t? Type extends 'string' | 'number' | 'integer' | 'boolean' | 'null'\n\t? SchemaPrimitiveTypeNameToType<Type>\n\t// Union of primitive types\n\t: Type extends [...infer R]\n\t? UnionOf<{ [K in keyof R]: SchemaPrimitiveTypeNameToType<R[K]> }>\n\t: never\n\n\t// Fallthrough\n\t: never;\n\ntype SchemaPrimitiveTypeNameToType<T> =\n\tT extends 'string' ? string :\n\tT extends 'number' | 'integer' ? number :\n\tT extends 'boolean' ? boolean :\n\tT extends 'null' ? null :\n\tnever;\n\ntype UnionOf<T> =\n\tT extends [infer First, ...infer Rest]\n\t? First | UnionOf<Rest>\n\t: never;\n\ntype IsRequired<K, RequiredList> =\n\tRequiredList extends []\n\t? false\n\n\t: RequiredList extends [K, ...infer _]\n\t? true\n\n\t: RequiredList extends [infer _, ...infer R]\n\t? IsRequired<K, R>\n\n\t: false;\n\ntype AdditionalPropertiesType<Schema> =\n\tSchema extends { additionalProperties: infer AP }\n\t? AP extends false ? {} : { [key: string]: TypeFromJsonSchema<Schema['additionalProperties']> }\n\t: {};\n\ntype MapSchemaToType<T> = T extends [infer First, ...infer Rest]\n\t? TypeFromJsonSchema<First> | MapSchemaToType<Rest>\n\t: never;\n\n"]}