export interface IDisposable {
    dispose(): void;
}
export type IEvent<T> = (listener: (e: T) => void) => IDisposable;
export declare class EventEmitter<T> {
    private listeners;
    readonly event: IEvent<T>;
    fire(args: T): void;
}
export interface IValueWithChangeEvent<T> {
    get value(): T;
    get onChange(): IEvent<T>;
}
export declare function constValue<T>(value: T): IValueWithChangeEvent<T>;
export declare class ValueWithChangeEvent<T> implements IValueWithChangeEvent<T> {
    private _value;
    private eventEmitter;
    constructor(initialValue: T);
    get value(): T;
    set value(newValue: T);
    get onChange(): IEvent<T>;
}
export declare function createTimeout(delay: number, callback: () => void): IDisposable;
export declare function setAndDeleteOnDispose<T>(set: Set<T>, item: T): IDisposable;
export declare function setAndDeleteOnDispose<TKey, TValue>(set: Map<TKey, TValue>, key: TKey, item: TValue): IDisposable;
export declare class Deferred<T = void> {
    private _state;
    readonly promise: Promise<T>;
    resolve: (value: T | PromiseLike<T>) => void;
    reject: (reason?: any) => void;
    constructor();
    get state(): "none" | "resolved" | "rejected";
}
export declare class Barrier<T> {
    private deferred;
    readonly unlock: (value: T | PromiseLike<T>) => void;
    readonly reject: (reason?: any) => void;
    readonly onUnlocked: Promise<T>;
    constructor();
    get state(): "none" | "resolved" | "rejected";
}
//# sourceMappingURL=base.d.ts.map