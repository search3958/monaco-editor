import { ValueWithChangeEvent } from "./base";
/**
 * Base class for implementing a MessageStream.
 * Provides an unreadMessage queue.
 */
export class BaseMessageStream {
    static id = 0;
    _unreadMessages = [];
    _onMessageCallback;
    id = BaseMessageStream.id++;
    _isClosed = new ValueWithChangeEvent(false);
    isClosed = this._isClosed;
    /**
     * Sets a callback for incoming messages.
     */
    setReadCallback(callback) {
        this._onMessageCallback = callback;
        if (!callback) {
            return;
        }
        while (this._unreadMessages.length > 0) {
            const msg = this._unreadMessages.shift();
            callback(msg);
        }
    }
    /**
     * Call this in derived classes to signal a new message.
     */
    _onMessage(message) {
        const hasReadAllQueuedMessages = this._unreadMessages.length === 0;
        if (hasReadAllQueuedMessages && this._onMessageCallback) {
            this._onMessageCallback(message);
        }
        else {
            this._unreadMessages.push(message);
        }
    }
    /**
     * Call this in derived classes to signal that the connection closed.
     */
    _onConnectionClosed() {
        this._isClosed.value = true;
    }
    log(logger) {
        return new StreamLogger(this, logger ?? new ConsoleMessageLogger());
    }
}
/**
 * Intercepts a stream for logging.
 */
export class StreamLogger {
    baseStream;
    logger;
    constructor(baseStream, logger) {
        this.baseStream = baseStream;
        this.logger = logger;
    }
    get isClosed() {
        return this.baseStream.isClosed;
    }
    setReadCallback(callback) {
        if (callback === undefined) {
            this.baseStream.setReadCallback(undefined);
            return;
        }
        this.baseStream.setReadCallback((readMessage) => {
            this.logger.log(this.baseStream, "incoming", readMessage);
            callback(readMessage);
        });
    }
    write(message) {
        this.logger.log(this.baseStream, "outgoing", message);
        return this.baseStream.write(message);
    }
    toString() {
        return `StreamLogger/${this.baseStream.toString()}`;
    }
}
/**
 * Logs messages to a `RpcLogger`.
 */
export class RpcStreamLogger extends StreamLogger {
    constructor(baseStream, rpcLogger) {
        super(baseStream, {
            log: (stream, type, message) => {
                const char = type === "incoming" ? "<-" : "->";
                rpcLogger.trace({
                    text: `${char} [${stream.toString()}] ${JSON.stringify(message)}`,
                    message: message,
                });
            },
        });
    }
}
/**
 * Logs messages to `console`.
 */
export class ConsoleStreamLogger extends StreamLogger {
    constructor(baseStream) {
        super(baseStream, new ConsoleMessageLogger());
    }
}
export class ConsoleMessageLogger {
    log(stream, type, message) {
        const char = type === "incoming" ? "<-" : "->";
        console.log(`${char} [${stream.toString()}] ${JSON.stringify(message)}`);
    }
}
//# sourceMappingURL=MessageStream.js.map