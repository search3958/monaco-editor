import { ValueWithChangeEvent } from "./common";
/**
 * Base class for implementing a MessageStream.
 * Provides an unreadMessage queue.
 */
export class BaseMessageTransport {
    static id = 0;
    _unprocessedMessages = [];
    _messageListener;
    id = BaseMessageTransport.id++;
    _state = new ValueWithChangeEvent({ state: "open" });
    state = this._state;
    /**
     * Sets a callback for incoming messages.
     */
    setListener(listener) {
        this._messageListener = listener;
        if (!listener) {
            return;
        }
        // _messageListener might change!
        while (this._unprocessedMessages.length > 0 && this._messageListener !== undefined) {
            const msg = this._unprocessedMessages.shift();
            this._messageListener(msg);
        }
    }
    /**
     * Writes a message to the stream.
     */
    send(message) {
        return this._sendImpl(message);
    }
    /**
     * Call this in derived classes to signal a new message.
     */
    _dispatchReceivedMessage(message) {
        const hasReadAllQueuedMessages = this._unprocessedMessages.length === 0;
        if (hasReadAllQueuedMessages && this._messageListener) {
            this._messageListener(message);
        }
        else {
            this._unprocessedMessages.push(message);
        }
    }
    /**
     * Call this in derived classes to signal that the connection closed.
     */
    _onConnectionClosed() {
        this._state.value = { state: 'closed', error: undefined };
    }
    log(logger) {
        return new StreamLogger(this, logger ?? new ConsoleMessageLogger());
    }
}
/**
 * Intercepts a stream for logging.
 */
export class StreamLogger {
    baseStream;
    logger;
    constructor(baseStream, logger) {
        this.baseStream = baseStream;
        this.logger = logger;
    }
    get state() {
        return this.baseStream.state;
    }
    setListener(listener) {
        if (listener === undefined) {
            this.baseStream.setListener(undefined);
            return;
        }
        this.baseStream.setListener((readMessage) => {
            this.logger.log(this.baseStream, "incoming", readMessage);
            listener(readMessage);
        });
    }
    send(message) {
        this.logger.log(this.baseStream, "outgoing", message);
        return this.baseStream.send(message);
    }
    toString() {
        return `StreamLogger/${this.baseStream.toString()}`;
    }
}
/**
 * Logs messages to a `RpcLogger`.
 */
export class RpcStreamLogger extends StreamLogger {
    constructor(baseStream, rpcLogger) {
        super(baseStream, {
            log: (stream, type, message) => {
                const char = type === "incoming" ? "<-" : "->";
                rpcLogger.trace({
                    text: `${char} [${stream.toString()}] ${JSON.stringify(message)}`,
                    message: message,
                });
            },
        });
    }
}
/**
 * Logs messages to `console`.
 */
export class ConsoleStreamLogger extends StreamLogger {
    constructor(baseStream) {
        super(baseStream, new ConsoleMessageLogger());
    }
}
export class ConsoleMessageLogger {
    log(stream, type, message) {
        const char = type === "incoming" ? "<-" : "->";
        console.log(`${char} [${stream.toString()}] ${JSON.stringify(message)}`);
    }
}
//# sourceMappingURL=MessageTransport.js.map