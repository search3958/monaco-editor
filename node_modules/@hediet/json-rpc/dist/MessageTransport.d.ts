import { IValueWithChangeEvent, ValueWithChangeEvent } from "./common";
import { Message } from "./JsonRpcTypes";
import { RpcLogger } from "./Logger";
/**
 * Represents a mechanism to send and receive messages.
 */
export interface IMessageTransport {
    get state(): IValueWithChangeEvent<ConnectionState>;
    send(message: Message): Promise<void>;
    /**
     * Sets a listener for received messages.
     * The listener might be called multiple times before this function returns.
     * The method allows reentrancy.
     */
    setListener(listener: MessageListener | undefined): void;
    /**
     * Returns a human readable representation of this stream.
     */
    toString(): string;
}
export type ConnectionState = {
    state: "connecting";
} | {
    state: "open";
} | {
    state: "closed";
    error: Error | undefined;
};
export type MessageListener = (message: Message) => void;
/**
 * Base class for implementing a MessageStream.
 * Provides an unreadMessage queue.
 */
export declare abstract class BaseMessageTransport implements IMessageTransport {
    private static id;
    private readonly _unprocessedMessages;
    private _messageListener;
    protected readonly id: number;
    private readonly _state;
    readonly state: ValueWithChangeEvent<ConnectionState>;
    /**
     * Sets a callback for incoming messages.
     */
    setListener(listener: MessageListener | undefined): void;
    /**
     * Writes a message to the stream.
     */
    send(message: Message): Promise<void>;
    protected abstract _sendImpl(message: Message): Promise<void>;
    /**
     * Returns human readable information of this message stream.
     */
    abstract toString(): string;
    /**
     * Call this in derived classes to signal a new message.
     */
    protected _dispatchReceivedMessage(message: Message): void;
    /**
     * Call this in derived classes to signal that the connection closed.
     */
    protected _onConnectionClosed(): void;
    log(logger?: IMessageLogger): IMessageTransport;
}
/**
 * Used by `StreamLogger` to log messages.
 */
export interface IMessageLogger {
    log(stream: IMessageTransport, type: "incoming" | "outgoing", message: Message): void;
}
/**
 * Intercepts a stream for logging.
 */
export declare class StreamLogger implements IMessageTransport {
    private readonly baseStream;
    private readonly logger;
    constructor(baseStream: IMessageTransport, logger: IMessageLogger);
    get state(): IValueWithChangeEvent<ConnectionState>;
    setListener(listener: ((readMessage: Message) => void) | undefined): void;
    send(message: Message): Promise<void>;
    toString(): string;
}
/**
 * Logs messages to a `RpcLogger`.
 */
export declare class RpcStreamLogger extends StreamLogger {
    constructor(baseStream: IMessageTransport, rpcLogger: RpcLogger);
}
/**
 * Logs messages to `console`.
 */
export declare class ConsoleStreamLogger extends StreamLogger {
    constructor(baseStream: IMessageTransport);
}
export declare class ConsoleMessageLogger implements IMessageLogger {
    log(stream: IMessageTransport, type: "incoming" | "outgoing", message: Message): void;
}
//# sourceMappingURL=MessageTransport.d.ts.map