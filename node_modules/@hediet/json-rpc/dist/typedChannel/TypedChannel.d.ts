import { Channel, RequestObject } from "../Channel";
import { RequestId, ErrorCode, JSONArray, JSONObject } from "../JsonRpcTypes";
import { RpcLogger } from "../Logger";
import { IMessageTransport } from "../MessageTransport";
import { IDisposable } from "../common";
import { ISerializer, SerializerTAny } from "../schema";
export declare const OptionalMethodNotFound: unique symbol;
export type OptionalMethodNotFound = typeof OptionalMethodNotFound;
export declare abstract class TypedChannelBase<TContext, TSendContext> {
    abstract request<TParams, TResponse, TOptional extends boolean>(requestType: RequestType<TParams, TResponse, unknown, string | undefined, TOptional>, args: TParams, context: TSendContext): Promise<TOptional extends true ? TResponse | OptionalMethodNotFound : TResponse>;
    abstract notify<TParams>(notificationType: NotificationType<TParams>, params: TParams, context: TSendContext): void;
    abstract registerNotificationHandler<TArgs>(type: NotificationType<TArgs>, handler: NotificationHandlerFunc<TArgs, TContext>): IDisposable;
    abstract registerRequestHandler<TArgs, TResponse, TError>(requestType: RequestType<TArgs, TResponse, TError>, handler: RequestHandlerFunc<TArgs, TResponse, TError, TContext>): IDisposable;
    contextualize<TNewContext, TNewSendContext>(args: {
        getNewContext: (context: TContext) => Promise<TNewContext> | TNewContext;
        getSendContext: (newSendContext: TNewSendContext) => Promise<TSendContext> | TSendContext;
    }): TypedChannelBase<TNewContext, TNewSendContext>;
}
export interface TypedChannelOptions {
    logger?: RpcLogger;
    /**
     * If true, any sent or received unexpected properties are ignored.
     */
    ignoreUnexpectedPropertiesInResponses?: boolean;
    sendExceptionDetails?: boolean;
}
/**
 * Represents a typed channel.
 * Call `startListen` to create the underlying channel
 * and to start processing all incoming messages.
 * At this point, all request and notification handlers should be registered.
 */
export declare class TypedChannel<TContext = void, TSendContext = void> extends TypedChannelBase<TContext, TSendContext> {
    private readonly channelCtor;
    static fromTransport(stream: IMessageTransport, options?: TypedChannelOptions): TypedChannel;
    private _requestSender;
    private readonly _handler;
    private readonly _unknownNotificationHandler;
    private _timeout;
    sendExceptionDetails: boolean;
    private readonly _logger;
    constructor(channelCtor: Channel<TContext, TSendContext>, options?: TypedChannelOptions);
    private listeningDeferred;
    onListening: Promise<void>;
    private readonly _requestDidErrorEventEmitter;
    readonly onRequestDidError: import("../common").IEvent<{
        error: RequestHandlingError;
    }>;
    /**
     * This method must be called to forward messages from the stream to this channel.
     * This is not done automatically on construction so that this instance
     * can be setup properly before handling messages.
     */
    startListen(): void;
    private checkChannel;
    private handleRequest;
    private handleNotification;
    registerUnknownNotificationHandler(handler: (notification: RequestObject) => void): IDisposable;
    registerRequestHandler<TArgs, TResponse, TError>(requestType: RequestType<TArgs, TResponse, TError>, handler: RequestHandlerFunc<TArgs, TResponse, TError, TContext>): IDisposable;
    registerNotificationHandler<TArgs>(type: NotificationType<TArgs>, handler: NotificationHandlerFunc<TArgs, TContext>): IDisposable;
    getRegisteredTypes(): Array<RequestType | NotificationType>;
    request<TParams, TResponse, TOptional extends boolean>(requestType: RequestType<TParams, TResponse, unknown, string, TOptional>, args: TParams, context: TSendContext): Promise<TOptional extends true ? TResponse | OptionalMethodNotFound : TResponse>;
    notify<TParams>(notificationType: NotificationType<TParams>, params: TParams, context: TSendContext): Promise<void>;
}
export type Result<TOk, TError> = OkResult<TOk> | ErrorResult<TError>;
export interface OkResult<TOk> {
    ok: TOk;
}
export type ErrorResult<TError> = {
    error: TError;
    errorMessage?: string;
    errorCode?: ErrorCode;
} | {
    error?: TError;
    errorMessage: string;
    errorCode?: ErrorCode;
};
export type RequestHandlerFunc<TArg, TResult, TError, TContext> = (arg: TArg, requestId: RequestId, context: TContext) => Promise<Result<TResult, TError>>;
export type NotificationHandlerFunc<TArg, TContext> = (arg: TArg, context: TContext) => void;
/**
 * Is thrown when handling the request raised an error.
 */
export declare class RequestHandlingError<T = any> extends Error {
    readonly data?: T | undefined;
    readonly code: ErrorCode;
    constructor(message: string, data?: T | undefined, code?: ErrorCode);
}
/**
 * Describes a request type.
 */
export declare class RequestType<TParams = unknown, TResponse = unknown, TError = unknown, TMethod extends string | undefined = string, TOptional extends boolean = false> {
    readonly method: TMethod;
    readonly paramsSerializer: ISerializer<TParams>;
    readonly resultSerializer: ISerializer<TResponse>;
    readonly errorSerializer: ISerializer<TError>;
    readonly isOptional: TOptional;
    readonly kind: "request";
    constructor(method: TMethod, paramsSerializer: ISerializer<TParams>, resultSerializer: ISerializer<TResponse>, errorSerializer: ISerializer<TError>, isOptional?: TOptional);
    withMethod(method: string): RequestType<TParams, TResponse, TError, string>;
    optional(): RequestType<TParams, TResponse, TError, TMethod, true>;
}
/**
 * Describes a notification type.
 */
export declare class NotificationType<TParams = unknown, TMethod = string> {
    readonly method: TMethod;
    readonly paramsSerializer: ISerializer<TParams>;
    readonly kind: "notification";
    constructor(method: TMethod, paramsSerializer: ISerializer<TParams>);
    withMethod(method: string): NotificationType<TParams, string>;
}
/**
 * Describes a notification type without static type validation.
 */
export declare function rawNotification(method: string): NotificationType<JSONObject | JSONArray | undefined>;
/**
 * Describes a request type as part of a `Contract`.
 */
export declare function requestType<TMethod extends string | undefined = undefined, TParams = ISerializer<{}>, TResult = ISerializer<void>, TError = ISerializer<undefined>>(request: {
    method?: TMethod;
    params?: TParams;
    result?: TResult;
    error?: TError;
}): RequestType<SerializerTAny<TParams>, SerializerTAny<TResult>, SerializerTAny<TError>, TMethod>;
export declare function unverifiedRequest<TParams = {}, TResult = void, TError = void, TMethod extends string | undefined = string>(request?: {
    method?: TMethod;
}): RequestType<TParams, TResult, TError, TMethod>;
/**
 * Describes a notification type as part of a `Contract`.
 */
export declare function notificationType<TMethod extends string | undefined = undefined, TParams = ISerializer<{}>>(notification: {
    method?: TMethod;
    params?: TParams;
}): NotificationType<SerializerTAny<TParams>, TMethod>;
export declare function unverifiedNotification<TParams, TMethod extends string | undefined = string>(request?: {
    method?: TMethod;
}): NotificationType<TParams, TMethod>;
//# sourceMappingURL=TypedChannel.d.ts.map