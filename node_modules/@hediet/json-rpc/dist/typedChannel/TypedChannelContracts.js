import { TypedChannel, OptionalMethodNotFound } from "./TypedChannel";
import { ErrorCode } from "../JsonRpcTypes";
/** Marks a type as error wrapper. */
export const IsErrorWrapper = Symbol();
/**
 * Wraps an error so that it can be distinguished from a successfully returned result.
 */
export class ErrorWrapper {
    error;
    static factory = (error) => {
        return new ErrorWrapper(error);
    };
    [IsErrorWrapper];
    constructor(error) {
        this.error = error;
    }
}
/**
 * Describes a new contract.
 */
export function contract(contractObj) {
    const server = transform(contractObj["server"]);
    const client = transform(contractObj["client"]);
    return new Contract(contractObj.tags || [], server, client);
}
function transform(requestMap) {
    const result = {};
    for (const [key, req] of Object.entries(requestMap)) {
        const method = req.method ? req.method : key;
        result[key] = req.withMethod(method);
    }
    return result;
}
export class Contract {
    tags;
    server;
    client;
    _onlyDesignTime() {
        return new Error("This property is not meant to be accessed at runtime");
    }
    get TContractObject() {
        throw this._onlyDesignTime();
    }
    get TClientInterface() {
        throw this._onlyDesignTime();
    }
    get TServerInterface() {
        throw this._onlyDesignTime();
    }
    get TClientHandler() {
        throw this._onlyDesignTime();
    }
    get TServerHandler() {
        throw this._onlyDesignTime();
    }
    get TTags() {
        throw this._onlyDesignTime();
    }
    constructor(tags = [], server, client) {
        this.tags = tags;
        this.server = server;
        this.client = client;
    }
    getInterface(typedChannel, myContract, otherContract, myInterface) {
        const counterpart = this.buildCounterpart(typedChannel, otherContract);
        const disposable = this.registerHandlers(typedChannel, myContract, myInterface, counterpart);
        return { counterpart, dispose: () => disposable.dispose() };
    }
    buildCounterpart(typedChannel, otherContract) {
        const counterpart = {};
        for (const [key, req] of Object.entries(otherContract)) {
            let method;
            if (req.kind === "request") {
                if (req.isOptional) {
                    method = async (args, context) => {
                        if (args === undefined) {
                            args = {};
                        }
                        try {
                            return await typedChannel.request(req, args, context);
                        }
                        catch (error) {
                            // TODO use proper types
                            if (error && error.code === ErrorCode.methodNotFound) {
                                return OptionalMethodNotFound;
                            }
                            throw error;
                        }
                    };
                }
                else {
                    method = (args, context) => {
                        if (args === undefined) {
                            args = {};
                        }
                        return typedChannel.request(req, args, context);
                    };
                }
            }
            else {
                method = (args, context) => {
                    if (args === undefined) {
                        args = {};
                    }
                    return typedChannel.notify(req, args, context);
                };
            }
            counterpart[key] = method;
        }
        return counterpart;
    }
    registerHandlers(typedChannel, myContract, myInterface, counterpart) {
        const disposables = [];
        for (const [key, req] of Object.entries(myContract)) {
            if (req.kind === "request") {
                let method = myInterface[key];
                if (!method) {
                    continue;
                }
                const handler = this.createRequestHandler(counterpart, method);
                disposables.push(typedChannel.registerRequestHandler(req, handler));
            }
            else {
                const method = myInterface[key];
                if (method) {
                    disposables.push(typedChannel.registerNotificationHandler(req, (args, context) => {
                        const notificationInfo = { context, counterpart };
                        // TODO maybe await and log errors?
                        method(args, notificationInfo);
                    }));
                }
            }
        }
        return { dispose: () => disposables.forEach(d => d.dispose()) };
    }
    createRequestHandler(counterpart, method) {
        return async (args, requestId, listenerContext) => {
            const requestInfo = {
                context: listenerContext,
                counterpart,
                newErr: ErrorWrapper.factory,
                requestId,
            };
            const result = await method(args, requestInfo);
            if (result instanceof ErrorWrapper) {
                return result.error;
            }
            return { ok: result };
        };
    }
    /**
     * Gets a server object directly from a stream by constructing a new `TypedChannel`.
     * It also registers the client implementation to the stream.
     * The channel starts listening immediately.
     */
    static getServerFromStream(contract, stream, options, clientImplementation) {
        const channel = TypedChannel.fromTransport(stream, options);
        const { server } = contract.getServer(channel, clientImplementation);
        channel.startListen();
        return { channel, server };
    }
    /**
     * Gets a client object directly from a stream by constructing a new `TypedChannel`.
     * It also registers the server implementation to the stream.
     * The channel starts listening immediately.
     */
    static registerServerToStream(contract, stream, options, serverImplementation) {
        const channel = TypedChannel.fromTransport(stream, options);
        const { client } = contract.registerServer(channel, serverImplementation);
        channel.startListen();
        return { channel, client };
    }
    getServer(typedChannel, clientImplementation) {
        const { counterpart, dispose } = this.getInterface(typedChannel, this.client, this.server, clientImplementation);
        return { server: counterpart, dispose };
    }
    registerServer(typedChannel, serverImplementation) {
        const { counterpart, dispose } = this.getInterface(typedChannel, this.server, this.client, serverImplementation);
        return { client: counterpart, dispose };
    }
    withContext() {
        return new Contract(this.tags, this.server, this.client);
    }
}
//# sourceMappingURL=TypedChannelContracts.js.map