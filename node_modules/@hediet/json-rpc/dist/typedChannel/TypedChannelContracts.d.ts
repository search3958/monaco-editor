import { RequestType, NotificationType, TypedChannel, ErrorResult, TypedChannelBase, TypedChannelOptions, OptionalMethodNotFound } from "./TypedChannel";
import { RequestId } from "../JsonRpcTypes";
import { IMessageTransport } from "../MessageTransport";
import { SerializerT } from "../schema";
import { IDisposable } from "../common";
/**
 * Describes a request type as part of a `Contract`.
 * The method is inferred from its position in the contract if not provided.
 */
export type ContractRequestType<TParams = unknown, TResult = unknown, TError = unknown, TOptional extends boolean = boolean> = RequestType<TParams, TResult, TError, string | undefined, TOptional>;
export type AnyRequestContract = ContractRequestType<any, any, any, boolean>;
export type AsRequestContract<T extends AnyRequestContract> = T;
/**
 * Describes a notification type as part of a `Contract`.
 * The method is inferred from its position in the contract if not provided.
 */
export type ContractNotificationType<TArgs = unknown> = NotificationType<TArgs, string | undefined>;
export type AsNotificationContract<T extends ContractNotificationType> = T;
/**
 * Describes one side of a contract.
 */
export type OneSideContract = Record<string, AnyRequestContract | ContractNotificationType<any>>;
export type AsOneSideContract<T extends OneSideContract> = T;
export type ContractToRequest<TRequestMap extends OneSideContract> = {
    [TRequest in keyof TRequestMap]: TRequestMap[TRequest] extends AnyRequestContract ? RequestType<SerializerT<TRequestMap[TRequest]["paramsSerializer"]>, SerializerT<TRequestMap[TRequest]["resultSerializer"]>, SerializerT<TRequestMap[TRequest]["errorSerializer"]>> : NotificationType<SerializerT<TRequestMap[TRequest]["paramsSerializer"]>>;
};
export type EmptyObjectToVoid<T> = {} extends T ? void | T : T;
export type ContractInterfaceOf<TRequestMap extends OneSideContract, TContext> = {
    [TRequest in keyof TRequestMap]: (arg: EmptyObjectToVoid<SerializerT<TRequestMap[TRequest]["paramsSerializer"]>>, context: TContext) => TRequestMap[TRequest] extends AnyRequestContract ? Promise<SerializerT<TRequestMap[TRequest]["resultSerializer"]>> | (TRequestMap[TRequest]['isOptional'] extends true ? OptionalMethodNotFound : never) : void;
};
/** Marks a type as error wrapper. */
export declare const IsErrorWrapper: unique symbol;
/**
 * Wraps an error so that it can be distinguished from a successfully returned result.
 */
export declare class ErrorWrapper<TError> {
    readonly error: ErrorResult<TError>;
    static factory: (error: ErrorResult<unknown>) => ErrorWrapper<unknown>;
    [IsErrorWrapper]: true;
    constructor(error: ErrorResult<TError>);
}
export type ContractHandlerOf<TRequestMap extends OneSideContract, TCounterPartRequestMap extends OneSideContract, TContext, TOtherContext> = ObjectWithOptional<{
    [TKey in keyof TRequestMap]: TRequestMap[TKey] extends AnyRequestContract ? {
        optional: TRequestMap[TKey]['isOptional'];
        type: (arg: SerializerT<TRequestMap[TKey]["paramsSerializer"]>, info: RequestHandlerInfo<SerializerT<TRequestMap[TKey]["errorSerializer"]>, ContractInterfaceOf<TCounterPartRequestMap, TOtherContext>, TContext>) => Promise<SerializerT<TRequestMap[TKey]["resultSerializer"]> | ErrorWrapper<SerializerT<TRequestMap[TKey]["errorSerializer"]>>>;
    } : {
        optional: true;
        type: (arg: SerializerT<TRequestMap[TKey]["paramsSerializer"]>, info: HandlerInfo<ContractInterfaceOf<TCounterPartRequestMap, TOtherContext>, TContext>) => void;
    };
}>;
export type ObjectWithOptional<T extends Record<string, {
    optional: boolean;
    type: any;
}>> = ({
    [K in keyof T]?: T[K]["type"];
} & {
    [K in keyof T as T[K]["optional"] extends false ? K : never]-?: T[K]["type"];
}) extends infer O ? {
    [K in keyof O]: O[K];
} : never;
/**
 * Describes a contract.
 */
export interface ContractObject {
    server: OneSideContract;
    client: OneSideContract;
}
/**
 * Describes a new contract.
 */
export declare function contract<TServer extends OneSideContract, TClient extends OneSideContract, TTags extends string = never>(contractObj: {
    name: string;
    tags?: TTags[];
    server: TServer;
    client: TClient;
}): Contract<TTags, {
    server: TServer;
    client: TClient;
}, void, void>;
/**
 * Provides additional information when handling a request or a notification.
 */
export interface HandlerInfo<TCounterPart, TListenerContext = never> {
    context: TListenerContext;
    /**
     * The implementation of the other contract.
     */
    counterpart: TCounterPart;
}
/**
 * Provides additional information when handling a request.
 */
export interface RequestHandlerInfo<TError, TCounterPart, TContext = never> extends HandlerInfo<TCounterPart, TContext> {
    /**
     * Creates a new error object that can be returned in request handlers.
     */
    newErr(error: ErrorResult<TError>): ErrorWrapper<TError>;
    /**
     * The id of the current request.
     */
    requestId: RequestId;
}
export declare class Contract<TTags extends string, TContractObject extends ContractObject, TContext, TSendContext> {
    readonly tags: TTags[];
    readonly server: ContractToRequest<TContractObject["server"]>;
    readonly client: ContractToRequest<TContractObject["client"]>;
    protected _onlyDesignTime(): Error;
    get TContractObject(): TContractObject;
    get TClientInterface(): ContractInterfaceOf<TContractObject["client"], TContext>;
    get TServerInterface(): ContractInterfaceOf<TContractObject["server"], TContext>;
    get TClientHandler(): ContractHandlerOf<TContractObject["client"], TContractObject["server"], TContext, TSendContext>;
    get TServerHandler(): ContractHandlerOf<TContractObject["server"], TContractObject["client"], TContext, TSendContext>;
    get TTags(): TTags;
    constructor(tags: TTags[] | undefined, server: ContractToRequest<TContractObject["server"]>, client: ContractToRequest<TContractObject["client"]>);
    protected getInterface(typedChannel: TypedChannelBase<TContext, TSendContext>, myContract: Record<string, NotificationType<any> | RequestType<any, any, any>>, otherContract: Record<string, NotificationType<any> | RequestType<any, any, any>>, myInterface: Record<string, Function>): {
        counterpart: Record<string, unknown>;
    } & IDisposable;
    private buildCounterpart;
    private registerHandlers;
    private createRequestHandler;
    /**
     * Gets a server object directly from a stream by constructing a new `TypedChannel`.
     * It also registers the client implementation to the stream.
     * The channel starts listening immediately.
     */
    static getServerFromStream<TContract extends Contract<any, {
        client: {};
        server: {};
    }, void, void>>(contract: TContract, stream: IMessageTransport, options: TypedChannelOptions, clientImplementation: TContract["TClientHandler"]): {
        server: TContract["TServerInterface"];
        channel: TypedChannel<void, void>;
    };
    /**
     * Gets a client object directly from a stream by constructing a new `TypedChannel`.
     * It also registers the server implementation to the stream.
     * The channel starts listening immediately.
     */
    static registerServerToStream<TContract extends Contract<any, {
        client: {};
        server: {};
    }, void, void>>(contract: TContract, stream: IMessageTransport, options: TypedChannelOptions, serverImplementation: TContract["TServerHandler"]): {
        client: TContract["TClientInterface"];
        channel: TypedChannel<void, void>;
    };
    getServer(typedChannel: TypedChannelBase<TContext, TSendContext>, clientImplementation: this["TClientHandler"]): {
        server: ContractInterfaceOf<TContractObject["server"], TContext>;
    } & IDisposable;
    registerServer(typedChannel: TypedChannelBase<TContext, TSendContext>, serverImplementation: this["TServerHandler"]): {
        client: ContractInterfaceOf<TContractObject["client"], TContext>;
    } & IDisposable;
    withContext<TNewContext, TNewSendContext = TSendContext>(): Contract<TTags, TContractObject, TNewContext, TNewSendContext>;
}
//# sourceMappingURL=TypedChannelContracts.d.ts.map