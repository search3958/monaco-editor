import { ErrorCode } from "../JsonRpcTypes";
import { StreamBasedChannel } from "../StreamBasedChannel";
import { createTimeout, Deferred, EventEmitter, setAndDeleteOnDispose } from "../common";
import { convertSerializer, Serializers } from "../schema";
export const OptionalMethodNotFound = Symbol("OptionalMethodNotFound");
export class TypedChannelBase {
    contextualize(args) {
        return new ContextualizedTypedChannel(this, args);
    }
}
class ContextualizedTypedChannel extends TypedChannelBase {
    underylingTypedChannel;
    converters;
    constructor(underylingTypedChannel, converters) {
        super();
        this.underylingTypedChannel = underylingTypedChannel;
        this.converters = converters;
    }
    async request(requestType, args, newContext) {
        const context = await this.converters.getSendContext(newContext);
        return this.underylingTypedChannel.request(requestType, args, context);
    }
    async notify(notificationType, params, newContext) {
        const context = await this.converters.getSendContext(newContext);
        return this.underylingTypedChannel.notify(notificationType, params, context);
    }
    registerNotificationHandler(type, handler) {
        return this.underylingTypedChannel.registerNotificationHandler(type, async (arg, context) => {
            const newContext = await this.converters.getNewContext(context);
            return await handler(arg, newContext);
        });
    }
    registerRequestHandler(requestType, handler) {
        return this.underylingTypedChannel.registerRequestHandler(requestType, async (arg, requestId, context) => {
            const newContext = await this.converters.getNewContext(context);
            return await handler(arg, requestId, newContext);
        });
    }
}
/**
 * Represents a typed channel.
 * Call `startListen` to create the underlying channel
 * and to start processing all incoming messages.
 * At this point, all request and notification handlers should be registered.
 */
export class TypedChannel extends TypedChannelBase {
    channelCtor;
    static fromTransport(stream, options = {}) {
        const channelFactory = StreamBasedChannel.createChannel(stream, options.logger);
        return new TypedChannel(channelFactory, options);
    }
    _requestSender = undefined;
    _handler = new Map();
    _unknownNotificationHandler = new Set();
    _timeout;
    sendExceptionDetails = false;
    _logger;
    constructor(channelCtor, options = {}) {
        super();
        this.channelCtor = channelCtor;
        this._logger = options.logger;
        this.sendExceptionDetails = !!options.sendExceptionDetails;
        this._timeout = createTimeout(1000, () => {
            if (!this._requestSender) {
                console.warn(`"${this.startListen.name}" has not been called within 1 second after construction of this channel. ` +
                    `Did you forget to call it?`, this);
            }
        });
    }
    listeningDeferred = new Deferred();
    onListening = this.listeningDeferred.promise;
    _requestDidErrorEventEmitter = new EventEmitter();
    onRequestDidError = this._requestDidErrorEventEmitter.event;
    /**
     * This method must be called to forward messages from the stream to this channel.
     * This is not done automatically on construction so that this instance
     * can be setup properly before handling messages.
     */
    startListen() {
        if (this._requestSender) {
            throw new Error(`"${this.startListen.name}" can be called only once, but it already has been called.`);
        }
        if (this._timeout) {
            this._timeout.dispose();
            this._timeout = undefined;
        }
        this._requestSender = this.channelCtor.connect({
            handleRequest: (req, id, context) => this.handleRequest(req, id, context),
            handleNotification: (req, context) => this.handleNotification(req, context),
        });
        this.listeningDeferred.resolve();
    }
    checkChannel(channel) {
        if (!channel) {
            throw new Error(`"${this.startListen.name}" must be called before any messages can be sent or received.`);
        }
        return true;
    }
    async handleRequest(request, requestId, context) {
        const handler = this._handler.get(request.method);
        if (!handler) {
            if (this._logger) {
                this._logger.debug({
                    text: `No request handler for "${request.method}".`,
                    data: { requestObject: request },
                });
            }
            return {
                error: {
                    code: ErrorCode.methodNotFound,
                    message: `No request handler for "${request.method}".`,
                    data: { method: request.method },
                },
            };
        }
        if (handler.kind != "request") {
            const message = `"${request.method}" is registered as notification, but was sent as request.`;
            if (this._logger) {
                this._logger.debug({
                    text: message,
                    data: { requestObject: request },
                });
            }
            return {
                error: {
                    code: ErrorCode.invalidRequest,
                    message: message,
                    data: { method: request.method },
                },
            };
        }
        const decodeResult = handler.requestType.paramsSerializer.deserializeFromJson(request.params);
        if (decodeResult.hasErrors) {
            const message = `Got invalid params: ${decodeResult.errorMessage}`;
            if (this._logger) {
                this._logger.debug({
                    text: message,
                    data: {
                        requestObject: request,
                        errorMessage: decodeResult.errorMessage,
                    },
                });
            }
            return {
                error: {
                    code: ErrorCode.invalidParams,
                    message,
                    data: {
                        errors: decodeResult.errorMessage,
                    },
                },
            };
        }
        else {
            const args = decodeResult.value;
            let response;
            try {
                const result = await handler.handler(args, requestId, context);
                if ("error" in result || "errorMessage" in result) {
                    const errorData = result.error
                        ? (handler.requestType.errorSerializer.serializeToJson(result.error))
                        : undefined;
                    const code = result.errorCode || ErrorCode.genericApplicationError;
                    const message = result.errorMessage || "An error was returned";
                    response = { error: { code, message, data: errorData } };
                }
                else {
                    const val = handler.requestType.resultSerializer.serializeToJson(result.ok);
                    response = { result: val };
                }
            }
            catch (exception) {
                if (exception instanceof RequestHandlingError) {
                    //  TODO: Introduce a better custom error
                    // What about data?
                    // Maybe default error data should be unknown
                    response = {
                        error: {
                            code: exception.code,
                            message: exception.message,
                        },
                    };
                }
                else {
                    if (this._logger) {
                        this._logger.warn({
                            text: `An exception was thrown while handling a request: ${exception}.`,
                            exception,
                            data: { requestObject: request },
                        });
                    }
                    response = {
                        error: {
                            code: ErrorCode.unexpectedServerError,
                            message: this.sendExceptionDetails
                                ? `An exception was thrown while handling a request: ${exception}.`
                                : "Server has thrown an unexpected exception",
                        },
                    };
                }
            }
            return response;
        }
    }
    async handleNotification(request, context) {
        const handler = this._handler.get(request.method);
        if (!handler) {
            for (const h of this._unknownNotificationHandler) {
                h(request);
            }
            if (this._unknownNotificationHandler.size === 0) {
                if (this._logger) {
                    this._logger.debug({
                        text: `Unhandled notification "${request.method}"`,
                        data: { requestObject: request },
                    });
                }
            }
            return;
        }
        if (handler.kind != "notification") {
            if (this._logger) {
                this._logger.debug({
                    text: `"${request.method}" is registered as request, but was sent as notification.`,
                    data: { requestObject: request },
                });
            }
            // dont send a response back as we are handling a notification.
            return;
        }
        const decodeResult = handler.notificationType.paramsSerializer.deserializeFromJson(request.params);
        if (decodeResult.hasErrors) {
            if (this._logger) {
                this._logger.debug({
                    text: `Got invalid params: ${decodeResult}`,
                    data: {
                        requestObject: request,
                        errorMessage: decodeResult.errorMessage,
                    },
                });
            }
            // dont send a response back as we are handling a notification.
            return;
        }
        const val = decodeResult.value;
        for (const handlerFunc of handler.handlers) {
            try {
                handlerFunc(val, context);
            }
            catch (exception) {
                if (this._logger) {
                    this._logger.warn({
                        text: `An exception was thrown while handling a notification: ${exception}.`,
                        exception,
                        data: { requestObject: request },
                    });
                }
            }
        }
    }
    registerUnknownNotificationHandler(handler) {
        return setAndDeleteOnDispose(this._unknownNotificationHandler, handler);
    }
    registerRequestHandler(requestType, handler) {
        const registeredHandler = this._handler.get(requestType.method);
        if (registeredHandler) {
            throw new Error(`Handler with method "${requestType.method}" already registered.`);
        }
        return setAndDeleteOnDispose(this._handler, requestType.method, {
            kind: "request",
            requestType,
            handler,
        });
    }
    registerNotificationHandler(type, handler) {
        let registeredHandler = this._handler.get(type.method);
        if (!registeredHandler) {
            registeredHandler = {
                kind: "notification",
                notificationType: type,
                handlers: new Set(),
            };
            this._handler.set(type.method, registeredHandler);
        }
        else {
            if (registeredHandler.kind !== "notification") {
                throw new Error(`Method "${type.method}" was already registered as request handler.`);
            }
            if (registeredHandler.notificationType !== type) {
                throw new Error(`Method "${type.method}" was registered for a different type.`);
            }
        }
        return setAndDeleteOnDispose(registeredHandler.handlers, handler);
    }
    getRegisteredTypes() {
        const result = [];
        for (const h of this._handler.values()) {
            if (h.kind === "notification") {
                result.push(h.notificationType);
            }
            else if (h.kind === "request") {
                result.push(h.requestType);
            }
        }
        return result;
    }
    async request(requestType, args, context) {
        if (!this.checkChannel(this._requestSender)) {
            throw new Error("Impossible");
        }
        const params = requestType.paramsSerializer.serializeToJson(args);
        assertObjectArrayOrNull(params);
        const response = await this._requestSender.sendRequest({
            method: requestType.method,
            params,
        }, context);
        if ("error" in response) {
            if (requestType.isOptional && response.error.code === ErrorCode.methodNotFound) {
                return OptionalMethodNotFound;
            }
            let errorData;
            if (response.error.data !== undefined) {
                const deserializationResult = requestType.errorSerializer.deserializeFromJson(response.error.data);
                if (deserializationResult.hasErrors) {
                    throw new Error(deserializationResult.errorMessage);
                }
                errorData = deserializationResult.value;
            }
            else {
                errorData = undefined;
            }
            const error = new RequestHandlingError(response.error.message, errorData, response.error.code);
            this._requestDidErrorEventEmitter.fire({ error });
            throw error;
        }
        else {
            const result = requestType.resultSerializer.deserializeFromJson(response.result);
            if (result.hasErrors) {
                throw new Error('Could not deserialize response: ' + result.errorMessage + `\n\n${JSON.stringify(response, null, 2)}`);
            }
            else {
                return result.value;
            }
        }
    }
    async notify(notificationType, params, context) {
        if (!this.checkChannel(this._requestSender)) {
            throw new Error();
        }
        const encodedParams = notificationType.paramsSerializer.serializeToJson(params);
        assertObjectArrayOrNull(encodedParams);
        this._requestSender.sendNotification({ method: notificationType.method, params: encodedParams }, context);
    }
}
function assertObjectArrayOrNull(val) {
    if (val !== null && Array.isArray(val) && typeof val !== "object") {
        throw new Error("Invalid value! Only null, array and object is allowed.");
    }
}
/**
 * Is thrown when handling the request raised an error.
 */
export class RequestHandlingError extends Error {
    data;
    code;
    constructor(message, data, code = ErrorCode.genericApplicationError) {
        super(message);
        this.data = data;
        this.code = code;
        Object.setPrototypeOf(this, RequestHandlingError.prototype);
    }
}
/**
 * Describes a request type.
 */
export class RequestType {
    method;
    paramsSerializer;
    resultSerializer;
    errorSerializer;
    isOptional;
    kind = "request";
    constructor(method, paramsSerializer, resultSerializer, errorSerializer, isOptional = false) {
        this.method = method;
        this.paramsSerializer = paramsSerializer;
        this.resultSerializer = resultSerializer;
        this.errorSerializer = errorSerializer;
        this.isOptional = isOptional;
    }
    withMethod(method) {
        return new RequestType(method, this.paramsSerializer, this.resultSerializer, this.errorSerializer);
    }
    optional() {
        return new RequestType(this.method, this.paramsSerializer, this.resultSerializer, this.errorSerializer, true);
    }
}
/**
 * Describes a notification type.
 */
export class NotificationType {
    method;
    paramsSerializer;
    kind = "notification";
    constructor(method, paramsSerializer) {
        this.method = method;
        this.paramsSerializer = paramsSerializer;
    }
    withMethod(method) {
        return new NotificationType(method, this.paramsSerializer);
    }
}
/**
 * Describes a notification type without static type validation.
 */
export function rawNotification(method) {
    return new NotificationType(method, Serializers.sAny());
}
/**
 * Describes a request type as part of a `Contract`.
 */
export function requestType(request) {
    return new RequestType(request.method, request.params ? convertSerializer(request.params) : Serializers.sEmptyObject(), request.result ? convertSerializer(request.result) : Serializers.sVoidFromNull(), request.error ? convertSerializer(request.error) : Serializers.sVoidFromNull());
}
// TODO remove TMethod
export function unverifiedRequest(request) {
    return new RequestType((request || {}).method, Serializers.sAny(), Serializers.sAny(), Serializers.sAny());
}
/**
 * Describes a notification type as part of a `Contract`.
 */
export function notificationType(notification) {
    return new NotificationType(notification.method, notification.params ? convertSerializer(notification.params) : Serializers.sEmptyObject());
}
// TODO remove TMethod
export function unverifiedNotification(request) {
    return new NotificationType((request || {}).method, Serializers.sAny());
}
//# sourceMappingURL=TypedChannel.js.map