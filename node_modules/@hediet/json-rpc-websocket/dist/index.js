import { BaseMessageTransport, EventEmitter } from "@hediet/json-rpc";
import WebSocket from "isomorphic-ws";
export * from "@hediet/json-rpc";
/**
 * Normalizes the given options to `NormalizedWebSocketOptions`.
 * It builds the address from a given host and port.
 */
export function normalizeWebSocketOptions(options) {
    if ("host" in options) {
        const useTls = options.forceTls;
        return {
            address: `${useTls ? "wss" : "ws"}://${options.host}:${options.port}`,
        };
    }
    else {
        return options;
    }
}
/**
 * Represents a stream through a web socket.
 * Use the static `connectTo` method to get a stream to a web socket server.
 */
export class WebSocketTransport extends BaseMessageTransport {
    socket;
    static connectTo(options) {
        const normalizedOptions = normalizeWebSocketOptions(options);
        const ws = new WebSocket(normalizedOptions.address);
        return new Promise((res, rej) => {
            // don't use `on` as it does not exist for browsers
            ws.onerror = (err) => {
                rej(err);
            };
            ws.onopen = () => {
                res(new WebSocketTransport(ws));
            };
        });
    }
    // We use unknown here, because we don't want to pull in the ws types publically.
    static fromWebSocket(socket) {
        return new WebSocketTransport(socket);
    }
    errorEmitter = new EventEmitter();
    onError = this.errorEmitter;
    constructor(socket) {
        super();
        this.socket = socket;
        socket.onmessage = (msg) => {
            // If we throw an exception here, the entire process will crash.
            try {
                const data = msg.data;
                if (typeof data === "string") {
                    const json = JSON.parse(data);
                    // TODO check type of json
                    this._dispatchReceivedMessage(json);
                }
                else {
                    throw new Error("Not supported"); // TODO test
                }
            }
            catch (error) {
                this.errorEmitter.fire({ error });
            }
        };
        socket.onclose = (_event) => {
            this._onConnectionClosed();
        };
    }
    /**
     * Closes the underlying socket.
     */
    close() {
        this.socket.close();
    }
    /**
     * Same as `close`.
     */
    dispose() {
        this.close();
    }
    _sendImpl(message) {
        const str = JSON.stringify(message);
        return new Promise((res, rej) => {
            this.socket.send(str, (err) => {
                if (err) {
                    rej(err);
                }
                else {
                    res();
                }
            });
        });
    }
    toString() {
        return `${this.id}@${this.socket.url}`;
    }
}
//# sourceMappingURL=index.js.map